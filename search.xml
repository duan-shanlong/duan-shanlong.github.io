<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Es6 中class特性</title>
    <url>/2022/11/21/Es6-%E4%B8%ADclass%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h5 id="创建一个class"><a href="#创建一个class" class="headerlink" title="创建一个class"></a>创建一个class</h5><p>注意：通过 class关键字 创建类， 默认首字母大写</p>
<pre><code>       1. constructor 是类的默认方法。 只要通过new 创建一个实例，就会调用这个方法，执行里面代码
       2. 一个类必须要有constructor方法，如果不写，默认为空的constructor会被添加
       3. constructor可以接收传递过来的参数， 默认返回实例对象
       4. 必须使用new调用
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Star&#123;</span><br><span class="line">     //类的公共属性，写在constructor()里面</span><br><span class="line">     constructor(name,age)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">         this.age = age;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> const kk = new Star(&#x27;西瓜&#x27;,12)</span><br></pre></td></tr></table></figure>

<h5 id="给类添加公共的方法"><a href="#给类添加公共的方法" class="headerlink" title="给类添加公共的方法"></a>给类添加公共的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Star&#123;</span><br><span class="line">            //类的公共属性，写在constructor()里面</span><br><span class="line">            constructor(name,age)&#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">                this.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            //函数方法不需要逗号，不需要function    </span><br><span class="line">            sing(song)&#123;</span><br><span class="line">                console.log(song)</span><br><span class="line">            &#125;</span><br><span class="line">            dance()&#123;</span><br><span class="line">                console.log(&#x27;dance&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const kk = new Star(&#x27;kk&#x27;,12)</span><br><span class="line">        console.log(kk)   //Star实例</span><br><span class="line">        kk.sing(&#x27;得到&#x27;)</span><br><span class="line">        </span><br><span class="line">        // 用class， 公共方法，默认就是定义在原型上的</span><br><span class="line">        console.log(kk.__proto__ === Star.prototype)  //true</span><br></pre></td></tr></table></figure>

<h5 id="类里面的this是指向实例的"><a href="#类里面的this是指向实例的" class="headerlink" title="类里面的this是指向实例的"></a>类里面的this是指向实例的</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Star &#123;</span><br><span class="line">     // 1. constructor里面的this指向 创建（new）出的实例</span><br><span class="line">     constructor(name, age)&#123;</span><br><span class="line">         this.name = name </span><br><span class="line">         this.age = age </span><br><span class="line">         console.log(this)   //Star 实例</span><br><span class="line">     &#125;</span><br><span class="line">     // 2. 类里面的方法中的this 指向的还是实例</span><br><span class="line">     sing(song)&#123;</span><br><span class="line">         console.log(this)   //Star 实例</span><br><span class="line">     &#125; </span><br><span class="line">     dance()&#123;</span><br><span class="line">         console.log(&#x27;dance&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> const ldh = new Star(&#x27;刘德华&#x27;, 36)</span><br></pre></td></tr></table></figure>

<h5 id="类的本质就是Function"><a href="#类的本质就是Function" class="headerlink" title="类的本质就是Function"></a>类的本质就是Function</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Star &#123;</span><br><span class="line">     constructor()&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     dance()&#123;</span><br><span class="line">         console.log(&#x27;dance&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(typeof Star)   // function </span><br><span class="line"> // 1. 类的本质就是函数， 可以简单认为类就是构造函数的另一种写法</span><br><span class="line"> // 2. 类有原型（对象）, 原型上默认有constructor属性，指向的就是类本身 class Star</span><br><span class="line"> // 3. 类 也可以在它的原型上添加方法</span><br><span class="line"> Star.prototype.sing = function()&#123;</span><br><span class="line">     console.log(&#x27;sing&#x27;)</span><br><span class="line"> &#125;</span><br><span class="line"> // 4. 实例的隐式原型指向构造函数（类）的显示原型</span><br><span class="line"> const kk = new Star()</span><br><span class="line"> console.log(kk.__proto__ === Star.prototype)   //true</span><br></pre></td></tr></table></figure>

<h5 id="！！！类的继承"><a href="#！！！类的继承" class="headerlink" title="！！！类的继承"></a>！！！类的继承</h5><p>通过extends继承父类的属性和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//父类</span><br><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;</span><br><span class="line">            console.log(&quot;dsf&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子类</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">// 继承父类的属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个父类</span><br><span class="line">class Father &#123;</span><br><span class="line">    constructor() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. 子类必须要在constructor方法里面调用super()</span><br><span class="line">// ==&gt; 如果子类里面写了constructor(), 就必须在constructor方法里面调用super()</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 如果子类没有写constructor() 会被默认添加，并且默认调用super()</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于 ==&gt; </span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Son()</span><br></pre></td></tr></table></figure>

<h5 id="super调用父类的构造函数"><a href="#super调用父类的构造函数" class="headerlink" title="super调用父类的构造函数"></a>super调用父类的构造函数</h5><p>super可以将参数传递回父类进行使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">     constructor(x, y) &#123;</span><br><span class="line">         this.x = x</span><br><span class="line">         this.y = y</span><br><span class="line">         console.log(x, y)</span><br><span class="line">     &#125;</span><br><span class="line">     // 求和</span><br><span class="line">     sum() &#123;</span><br><span class="line">         console.log(this.x + this.y)   //8</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Son extends Father &#123;</span><br><span class="line">     constructor(x, y) &#123;</span><br><span class="line">         // 1. super必须放在this之前，super表示调用父类的构造函数</span><br><span class="line">         super(x, y)</span><br><span class="line">         // 这里的x,y相当于new的时候，给实例添加属性x, y</span><br><span class="line">         this.x = x</span><br><span class="line"></span><br><span class="line">         this.y = y</span><br><span class="line">         this.color = &#x27;orange&#x27;</span><br><span class="line">     &#125;</span><br><span class="line">     // 减法</span><br><span class="line">     minus() &#123;</span><br><span class="line">         console.log(this.x - this.y) //2</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> const son = new Son(5, 3)</span><br><span class="line"> son.minus()</span><br><span class="line"> son.sum()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Node.js Es6模块化和koa快速方便编写接口</title>
    <url>/2022/11/19/Node-js-Es6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8Ckoa%E5%BF%AB%E9%80%9F%E6%96%B9%E4%BE%BF%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a><strong>ES6的模块化</strong></h1><h2 id="ES6的模块化介绍及使用准备"><a href="#ES6的模块化介绍及使用准备" class="headerlink" title="ES6的模块化介绍及使用准备"></a><strong>ES6的模块化介绍及使用准备</strong></h2><blockquote>
<p>最新的官方的模块化标准，客户端和服务端都可以使用，之后咱们基本上模块化的语法用的都是这个</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">传送门:mdn-import</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">传送门:mdn-export</a></p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a><strong>概念:</strong></h3><ul>
<li>在 <code>ES6</code> 模块化规范诞生之前，<code>JavaScript</code> 社区已经尝试并提出了<code>AMD</code>、<code>CMD</code>、<code>CommonJS</code> 等模块化规范。</li>
<li>这些由社区提出的模块化标准，还是存在一定的<strong>差异性与局限性</strong>–<strong>他不通用</strong><ul>
<li><code>AMD</code> 和 <code>CMD</code> 适用于<strong>浏览器端</strong>的 <code>Javascript</code> 模块化</li>
<li><code>CommonJS</code> 适用于<strong>服务器端</strong>的 <code>Javascript</code> 模块化</li>
</ul>
</li>
<li>过多的模块化规范给开发者增加了<strong>学习的难度与开发的成本</strong>。——因此，官方的<code>ES6</code> 模块化规范诞生了！</li>
<li>相信再<strong>不久的将来</strong>:前后端开发:都可以使用<code>ES6</code>的模块化，<strong>开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。</strong></li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><ol>
<li>每个 <code>js</code> 文件都是一个独立的模块</li>
<li>导入其它模块成员使用 <code>import</code> 关键字</li>
<li>向外共享模块成员使用 <code>export</code> 关键字</li>
<li><code>Node.js</code>使用准备<ol>
<li><code>package.json</code>中的<code>type</code>属性改为<code>module</code></li>
<li>安装的<code>node</code>版本大于等于<code>13.0</code></li>
</ol>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;01.coding&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;01.ES6的模块化.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6模块语法-默认的导出和导入"><a href="#ES6模块语法-默认的导出和导入" class="headerlink" title="ES6模块语法-默认的导出和导入"></a><strong>ES6模块语法-默认的导出和导入</strong></h2><blockquote>
<p>接下来咱们来学习ES6模块化中的默认导出和导入</p>
<p><a href="https://es6.ruanyifeng.com/#docs/module">传送门:ES6-module</a></p>
</blockquote>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a><strong>语法:</strong></h3><ol>
<li>导出： <code>export default 默认导出的成员</code></li>
<li>导入： <code>import 接收名称 from &#39;模块&#39;</code></li>
</ol>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码:"></a><strong>参考代码:</strong></h3><ol>
<li>导出</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> food = <span class="string">&#x27;青椒土豆丝&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dogs = [<span class="string">&#x27;哈士奇&#x27;</span>, <span class="string">&#x27;萨摩耶&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> stu = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;王磊&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: <span class="string">&#x27;刘俊杰&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name = <span class="string">&#x27;rose&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>你好呀！`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露一个出去</span></span><br><span class="line"><span class="comment">// export default food</span></span><br><span class="line"><span class="comment">// 都暴露出去</span></span><br><span class="line"><span class="comment">// export default 只能写一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  food,</span><br><span class="line">  dogs,</span><br><span class="line">  stu,</span><br><span class="line">  sayHi,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>导入</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可</span></span><br><span class="line"><span class="keyword">import</span> result <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure>

<h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1:"></a>Q1:</h3><p>咱们学习了ES模块语法的默认导出和导入:</p>
<ul>
<li><code>export default</code>可以写几次？<ol>
<li>一次</li>
</ol>
</li>
<li><code>export default</code>导出的模块外部如何导入?<ol>
<li><code>import 变量名 from &#39;地址.js&#39;</code></li>
</ol>
</li>
<li>使用ESM导入导出需要注意的点有哪些？<ol>
<li>package.json 中需要设置 <code>&quot;type&quot;:&quot;module&quot;</code></li>
<li>.js 不能省略</li>
<li>路径不能使用模板字符串</li>
</ol>
</li>
</ul>
<h2 id="ES6模块化语法-按需导出和导入"><a href="#ES6模块化语法-按需导出和导入" class="headerlink" title="ES6模块化语法 - 按需导出和导入"></a><strong>ES6模块化语法 - 按需导出和导入</strong></h2><blockquote>
<p>接下来咱们来学习如何按需的导出和导入</p>
</blockquote>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a><strong>语法</strong></h3><p><strong>导出</strong></p>
<ol>
<li><code>export const s1 = 10</code></li>
<li>或者<code>export &#123;变量1,变量2,方法....&#125;</code></li>
<li>可以和<code>export default</code>一起使用</li>
</ol>
<p><strong>导入:</strong></p>
<ol>
<li><code>import &#123; 按需导入的名称 &#125; from &#39;模块标识符&#39;</code></li>
<li>使用<code>as</code>起别名：<ol>
<li><code>import &#123; 按需导出的名称 as 别名 &#125; from &#39;./modules/02.按需导出.js&#39;</code></li>
</ol>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; food &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/02.按需导出.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;food:&#x27;</span>, food)</span><br><span class="line"><span class="comment">// 导入 + 起别名</span></span><br><span class="line"><span class="keyword">import</span> &#123; food <span class="keyword">as</span> fd &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/02.按需导出.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fd:&#x27;</span>, fd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入export default的内容</span></span><br><span class="line"><span class="keyword">import</span> result <span class="keyword">from</span> <span class="string">&#x27;./modules/02.按需导出.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result:&#x27;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入可以和 按需导入一起使用</span></span><br><span class="line"><span class="keyword">import</span> result, &#123; food &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/02.按需导出.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2:"></a>Q2:</h3><ul>
<li>按需导出可以和默认导出一起使用吗？  可以</li>
<li>按需导出只能写一个，还是可以写多个<ol>
<li><strong>n个</strong></li>
</ol>
</li>
<li>按需导入起别名用什么关键字？<ol>
<li><code>as</code></li>
</ol>
</li>
<li>按需导出和默认导出的取舍? 什么时候使用？<ol>
<li>看<strong>需求</strong></li>
<li>只需要导出一个内容,可以<strong>默认</strong></li>
<li>有多个:<strong>按需</strong></li>
</ol>
</li>
</ul>
<h2 id="ES6模块化语法-全部导入"><a href="#ES6模块化语法-全部导入" class="headerlink" title="ES6模块化语法 - 全部导入"></a><strong>ES6模块化语法 - 全部导入</strong></h2><blockquote>
<p>如果想要一次性导入所有的内容，还有一种语法哦,这个语法用的不多,了解即可</p>
</blockquote>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h3><ol>
<li><code>as</code> 是固定语法</li>
<li><code>myModule</code>是起的名字，可以根据需求调整</li>
<li>之后通过<code>myModule</code>点出需要的内容即可</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;/modules/my-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ES6模块化语法-直接导入"><a href="#ES6模块化语法-直接导入" class="headerlink" title="ES6模块化语法 - 直接导入"></a><strong>ES6模块化语法 - 直接导入</strong></h2><blockquote>
<p>有时候我们只希望执行某个模块中的代码，并不需要得到模块中向外共享的成员，可以选择直接导入</p>
</blockquote>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a><strong>语法</strong></h3><ol>
<li><code>import &#39;模块的路径&#39;</code><ol>
<li>模块的代码</li>
</ol>
 <figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 xxx.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>导入的语法 <figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">import</span> <span class="string">&#x27;xxx.js&#x27;</span></span><br><span class="line">       <span class="comment">// 即可看到循环输出的内容</span></span><br></pre></td></tr></table></figure>
 这个语法并不能获取模块内的成员<code>import &#39;模块的路径&#39;</code>，作用是 ⇒  执行 <strong>模块的代码</strong><h2 id="ES6模块化语法-浏览器端使用"><a href="#ES6模块化语法-浏览器端使用" class="headerlink" title="ES6模块化语法 - 浏览器端使用"></a><strong>ES6模块化语法 - 浏览器端使用</strong></h2><blockquote>
<p>到目前为止测试的环境基本都是Node.js，但是作为前端开发者，咱们编写的代码大部分情况下运行的为止是浏览器，刚刚学习的ES6的模块化语法，在浏览器中可以使用吗？</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">传送门：MDN-import</a></p>
</blockquote>
<h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a><strong>语法：</strong></h3><ol>
<li><code>script</code>标签设置<code>type=module</code></li>
<li>内部写<code>ES6</code>的<code>import</code>语法即可</li>
<li>必须要通过服务器的方式 运行页面,直接通过浏览器打开(<strong>报错</strong>)<ol>
<li><code>serve</code>全局模块</li>
<li><strong>vscode</strong>的<code>live serve</code> 插件</li>
</ol>
</li>
</ol>
 <figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="comment">// 默认导入</span></span><br><span class="line">  <span class="keyword">import</span> myTool <span class="keyword">from</span> <span class="string">&#x27;./modules/myModule.js&#x27;</span></span><br><span class="line">  <span class="comment">// 上面学习的所有语法都可以使用哦</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
 <strong><strong>兼容性</strong></strong> <a href="https://caniuse.com/?search=import">“import” | Can I use… Support tables for HTML5, CSS3, etc</a> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c466fd97-6587-4edd-a89e-0c0ae6aa82bd/Untitled.png" alt="Untitled"><ul>
<li><code>新式浏览器</code>中是否可以直接使用ES6的模块化语法？<ol>
<li>可以</li>
<li><code>type=module</code></li>
<li><strong>服务器</strong>的方式</li>
</ol>
</li>
</ul>
<h2 id="补充-yarn包管理器"><a href="#补充-yarn包管理器" class="headerlink" title="补充 - yarn包管理器"></a><strong>补充 - yarn包管理器</strong></h2><blockquote>
<p>最后补充一个也蛮流行的包管理工具</p>
<p><a href="https://classic.yarnpkg.com/en/docs/install#windows-stable">传送门:yarn</a></p>
<p><a href="https://blog.csdn.net/qq_64970126/article/details/125818888">传送门:yarn全局安装配置</a></p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念:"></a><strong>概念:</strong></h3><ol>
<li><code>npm</code>:官方的管理工具</li>
<li><code>yarn</code>:第三方的包管理工具–<strong>facebook</strong></li>
<li>比如:<ol>
<li><code>appstore</code>和第三方商店</li>
</ol>
</li>
</ol>
 快速、可靠、安全的依赖管理工具。和 npm 类似, 都是包管理工具, 可以用于下载包 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i dayjs</span><br></pre></td></tr></table></figure>
 下载地址: <a href="https://yarn.bootcss.com/docs/install/#windows-stable">https://yarn.bootcss.com/docs/install/#windows-stable</a> windows本   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i yarn -g</span><br></pre></td></tr></table></figure>
 mac本通过命令全局安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm i yarn -g</span><br></pre></td></tr></table></figure>
 <strong>基本命令:</strong> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 初始化</span><br><span class="line">  yarn init  /  yarn init -y</span><br><span class="line"></span><br><span class="line">2. 添加依赖</span><br><span class="line">  yarn add [package]</span><br><span class="line">  yarn add [package]@[version]</span><br><span class="line"></span><br><span class="line">3. 移除包</span><br><span class="line">  yarn remove [package]</span><br><span class="line"></span><br><span class="line">4. 安装项目全部依赖</span><br><span class="line">  yarn 或者 yarn install</span><br><span class="line"></span><br><span class="line">5. 全局</span><br><span class="line">  安装: yarn global add [package]</span><br><span class="line">  卸载: yarn global remove [package]</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li>yarn和npm的使用取舍?<ol>
<li>公司主要使用的是哪个就用哪个</li>
<li>区别就是是否有 yarn.lock</li>
</ol>
</li>
<li><strong>使用注意:</strong><ol>
<li>一个项目中 不要</li>
<li><code>yarn</code>和<code>npm</code>混着用<ol>
<li><code>axios,dayjs</code>用<code>npm</code>装</li>
<li><code>webpack</code>用<code>yarn</code>装</li>
</ol>
</li>
<li>npm—&gt;换成yarn<ol>
<li>删掉<code>node_module</code>,<code>package-lock.json</code></li>
<li>就可以放心大胆的使用<code>yarn</code></li>
</ol>
</li>
<li>yarn–&gt;npm<ol>
<li>删掉<code>node_module</code>,<code>yarn.lock</code></li>
<li>就可以放心大胆的使用<code>npm</code></li>
</ol>
</li>
</ol>
  <a href="https://blog.csdn.net/u012384510/article/details/121200358">npm、yarn、cnpm、pnpm 使用操作都在这了_若川视野的博客-CSDN博客</a>  <a href="https://juejin.cn/post/7127295203177676837#heading-2">pnpm 是凭什么对 npm 和 yarn 降维打击的</a>  <a href="https://juejin.cn/post/7053340250210795557">都2022年了，pnpm快到碗里来！</a><h1 id="Koa2"><a href="#Koa2" class="headerlink" title="Koa2"></a>Koa2</h1>  <a href="https://www.koajs.com.cn/">Koa(koa.js)中文网 – 基于 Node.js 平台的下一代 web 开发框架</a>  koa 是由 <code>Express 原班人马</code>打造的，致力于成为一个更小、更富有表现力、更健壮的 <code>Web 框架</code>。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。<h3 id="Koa-middleware洋葱模型"><a href="#Koa-middleware洋葱模型" class="headerlink" title="Koa-middleware洋葱模型"></a>Koa-middleware洋葱模型</h3>  <a href="https://github.com/koajs/koa/blob/master/docs/guide.md#writing-middleware">koa/guide.md at master · koajs/koa</a>  <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/70eb648d-9fca-486d-a069-77ef57c03f10/Untitled.png" alt="Untitled">  ⇒  <a href="https://www.eggjs.org/intro/egg-and-koa">Egg and Koa - Egg</a>  <a href="https://juejin.cn/post/6890259747866411022#heading-9">如何更好地理解中间件和洋葱模型</a>  <a href="https://zhuanlan.zhihu.com/p/417163957">【Node】深入浅出 Koa 的洋葱模型</a></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX总结和分析</title>
    <url>/2022/11/19/AJAX%E6%80%BB%E7%BB%93%E5%92%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h1><ol>
<li><p>创建xhr实例           const xhr = new XMLHttpRequest()</p>
</li>
<li><p>设置请求方法和地址        xhr.open(‘GET’, url)</p>
</li>
<li><p>如果是POST请求 ，告诉后端发送的参数是什么形式的       xhr.setRequestHeader(‘content-type’,’application/json’)</p>
</li>
<li><p>发送请求         xhr.send()</p>
</li>
<li><p>注册回调      </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&#x27;POST&#x27;,url)</span><br><span class="line">xhr.setRequestHeader(&#x27;content-type&#x27;,&#x27;application/x-www-form-                   urlencoded&#x27;)</span><br><span class="line">xhr.send(params)</span><br><span class="line">xhr.responseType = &#x27;json&#x27;</span><br><span class="line">xhr.addEventListener(&#x27;readystatechange&#x27;,()=&gt;&#123;</span><br><span class="line">    if(xhr.readyState !==4) return</span><br><span class="line">    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300)&#123;</span><br><span class="line">        console.log(xhr.response)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#x27;错误&#x27;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>readyState  ==&gt; 请求状态码  ， xhr的状态</p>
<p>0  表示请求未初始化，还没有调用 open()</p>
<p>1  表示服务器已建立 但是还没有 调用send()</p>
<p>2  请求已接收， 正在处理中 </p>
<p>3  请求处理中  已经有部分数据响应了，没有全部完成</p>
<p>4  请求已完成 （全部数据已经下载完了）</p>
<p>status http状态码</p>
<p>表示请求成功的http状态码  200-299</p>
<p>xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304</p>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>fetch 两段 then，错误全 catch</p>
<p>fetch 两个参数，url，config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        fetch(url,&#123;</span><br><span class="line">            method:&quot;post&quot;,</span><br><span class="line">            headers:&#123;&#x27;content-type&#x27;:&quot;application/json&quot;&#125;,</span><br><span class="line">            body:JSON.stringify(params)</span><br><span class="line">        &#125;).then(res =&gt; res.json())</span><br><span class="line">        .then(res =&gt; console.log(res))</span><br><span class="line">        .catch(err =&gt; console.log(err))</span><br><span class="line">//get </span><br><span class="line">        fetch(&#x27;http://ajax-api.itheima.net/api/news&#x27;)</span><br><span class="line">        .then(res =&gt; res.json())</span><br><span class="line">        .then(res =&gt; console.log(res))</span><br><span class="line">        .catch(err =&gt; console.log(err))</span><br><span class="line">//post</span><br><span class="line">        fetch(&#x27;http://ajax-api.itheima.net/api/login&#x27;,&#123;</span><br><span class="line">            method:&quot;post&quot;,</span><br><span class="line">            headers:&#123;&#x27;content-type&#x27;:&quot;application/json&quot;&#125;,</span><br><span class="line">            body:JSON.stringify(params)</span><br><span class="line">        &#125;).then(res =&gt; res.json())</span><br><span class="line">        .then(res =&gt; console.log(res))</span><br><span class="line">        .catch(err =&gt; console.log(err))</span><br></pre></td></tr></table></figure>

<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">axions(&#123;</span><br><span class="line">method:&quot;POST&quot;,</span><br><span class="line">data:&#123;&#125;, // 直接绑定 data （fetch 需要转换格式绑定在 body 上）</span><br><span class="line">params: &#123;&#125;， // params 会绑定在 url 查询上</span><br><span class="line">headers:&#123;</span><br><span class="line">&quot;content-type&quot;:&quot;application/json&quot; // headers 与 fetch ⼀致，</span><br><span class="line">但是默认值是 “application/json”</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">// res.data 返回结果，res.status 返回状态</span><br><span class="line">// 没有第⼆段 then</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//get</span><br><span class="line">axios(&#123;url&#125;)</span><br><span class="line">.then(res =&gt; console.log(res))</span><br><span class="line"></span><br><span class="line">//post</span><br><span class="line">axios(&#123;</span><br><span class="line">method:&quot;POST&quot;,</span><br><span class="line">data:&#123;&#125;,</span><br><span class="line">params: &#123;加载地址后面的&#125;，</span><br><span class="line">headers:&#123;&quot;content-type&quot;:&quot;application/json&quot; &#125;</span><br><span class="line">&#125;).then(res =&gt; console.log(res。data))</span><br></pre></td></tr></table></figure>

<h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p><strong>宏任务</strong></p>
<p>1.script</p>
<p>2.setTimeout</p>
<p>3.setInterval </p>
<p>4.setImmediate</p>
<p>5.UI事件</p>
<p>6.addEventListener</p>
<p>7.I/O(Node.js)</p>
<p><strong>微任务</strong></p>
<p>1.promise.then()  promise.catch()</p>
<p>2.async-await</p>
<p>3.mutationObserver  &gt;&gt;&gt;监听DOM的改变</p>
<p>4.process.NextTick()  &gt;&gt;&gt;&gt; Node</p>
<p>宏 batch 批处理 它干了很多事（宏任务里面有多个微任务）</p>
<p>一个宏任务，可以发起，很多个微任务（微任务列表）</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p><strong>宏任务 –&gt; 微任务队列 –&gt; 渲染 –&gt; 下⼀个宏任务 –&gt; 下⼀个微任务队列 …</strong></p>
<p>1.首先script代码块可以看作是第一个宏任务，开始第一个Tick事件循环</p>
<p>2.首先执行script代码块中的同步代码</p>
<p>3.如果遇到宏任务，就放到宏任务队列中等待执行，如果遇到微任务，放到微任务队列中</p>
<p>4.再去执行下一个宏任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&#x27;async1 start&#x27;)</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(&#x27;async1 end&#x27;)</span><br><span class="line">    // async2().then(</span><br><span class="line">    //     console.log(&#x27;async1 end&#x27;)</span><br><span class="line">    // )</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">async1();</span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line"></span><br><span class="line">//script start</span><br><span class="line">//async1 start</span><br><span class="line">//async2 </span><br><span class="line">//promise1 </span><br><span class="line">//script end</span><br><span class="line">//async1 end</span><br><span class="line">//promise2</span><br><span class="line">//setTimeout</span><br></pre></td></tr></table></figure>

<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化 Promise</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">// ⼀个异步回调</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">// 异步回调中调⽤ resolve 和 reject</span><br><span class="line">resolve(&quot;成功&quot;);</span><br><span class="line">// 失败</span><br><span class="line">reject(&quot;失败&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">// 封装⼀个 返回 Promise 的函数</span><br><span class="line">function wait(n) &#123;</span><br><span class="line">// 必须 return promise</span><br><span class="line">return new Promise((res) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">res();</span><br><span class="line">&#125;, n);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">// Promise 可以链式调⽤，如果.then 返回 Promise，则下⼀个 .then 是 Promise 的</span><br><span class="line">resolve，如果.then 返回值，则下⼀个 .then 参数是该值</span><br><span class="line">wait(1000)</span><br><span class="line">.then(() =&gt; wait(2000))</span><br><span class="line">.then(() =&gt; wait(1000));</span><br></pre></td></tr></table></figure>



<h3 id="promise推导"><a href="#promise推导" class="headerlink" title="promise推导"></a>promise推导</h3><p><em><strong>1.闭包    2.异步闭包    3.异步回调    4.回调地狱    5.promise   6.链式调用</strong></em></p>
<p>1.等号右边的是值，等号左边的是引用         引用：存储一个值的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = &#123; value: 1 &#125;;</span><br><span class="line">let value = a.value;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">      a.value = 2;</span><br><span class="line">&#125;, 1000);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">       console.log(value); // 1</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>



<p>2.函数闭包，专门为了异步存在</p>
<p>函数可以访问，外部特定时刻的<strong>引用</strong> —— 时间线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">值的引用：改变了栈里面的值，引用的是同一个值，值改变其他引用也会变</span><br><span class="line">第一种情况：  let a = 1;</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(a);  //1</span><br><span class="line">          a = 2;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(a);   //1</span><br><span class="line">        &#125;, 500);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">第二种情况：  let a = 1;</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(a);  //1</span><br><span class="line">          a = 2;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(a);   //2</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">记住了特定时刻的a值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象的引用：对象里面的属性值改变，不会影响其他的引用</span><br><span class="line">这里的value2和a存储在不同的空间中，互不影响</span><br><span class="line">        const a = &#123; value: 1 &#125;;</span><br><span class="line">        const value2 = a.value; // a.value 是右值</span><br><span class="line">        // const &#123;value2&#125; = a // 解构赋值</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(value2);   //1</span><br><span class="line">          a.value = 2;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(value2);    //1</span><br><span class="line">        &#125;, 2000);</span><br></pre></td></tr></table></figure>

<p>3.函数当作参数传递（回调），在异步结果中调用（异步回调）</p>
<p>因为函数作用域存在，所以回调在异步中调用时，可以拿到<strong>最新</strong>的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">function wait(cb) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line">function callback() &#123;</span><br><span class="line">  console.log(a);  //2</span><br><span class="line">&#125;</span><br><span class="line">wait(callback);</span><br><span class="line">a = 2;</span><br></pre></td></tr></table></figure>

<p>4.异步回调的回调地狱</p>
<p>出现的问题：</p>
<ol>
<li>取值取引用问题</li>
<li>常量冲突</li>
<li>变量遮蔽</li>
<li>大椎形代码</li>
</ol>
<p>待一段时间，干一件事，再等待一段时间，再干一件事</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">嵌套太多，分不清楚引用的是谁了，后面的变量会遮蔽前面的值</span><br><span class="line">const a = &#123; value: 1 &#125;;</span><br><span class="line">        const &#123; value &#125; = a;</span><br><span class="line">        wait(() =&gt; &#123;</span><br><span class="line">          // 常量冲突</span><br><span class="line">          const b = 1;</span><br><span class="line">          console.log(1);</span><br><span class="line">          wait((res) =&gt; &#123;</span><br><span class="line">            console.log(2);</span><br><span class="line">            // 变量遮蔽</span><br><span class="line">            wait((res) =&gt; &#123;</span><br><span class="line">              console.log(res);</span><br><span class="line">              console.log(3);</span><br><span class="line">              b = 2;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>5.promise  用来解决回调地狱的  （ 让异步任务进行同步处理）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function wait(n) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(`等待$&#123;n&#125;毫秒`); // .then 的回调，在这里跑</span><br><span class="line">    &#125;, n);</span><br><span class="line">    // 然后   一段时间以后</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">wait(1000).then((res) =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>6.promise 链式调用     就是（promise.then()）</p>
<p>等待一段时间，干一件事，再等待一段时间，再干一件事 …</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function wait(n) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(`等待$&#123;n&#125;毫秒`); // .then 的回调，在这里跑</span><br><span class="line">    &#125;, n);</span><br><span class="line">    // 然后 / 一段时间以后</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">wait(1000)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    // 当 .then 返回的值是 promise，下一个.then（的参数）是promise的resolve</span><br><span class="line">    return wait(1000);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    // 当 .then 返回的值，不是 promise 的时候，下一个 .then 就是这个值</span><br><span class="line">    return &quot;立即执行&quot;;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>获取⼀个 Promise 列表中，所有 Promise resolve 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all([promise1, promise2]).then((res) =&gt; &#123;</span><br><span class="line">const [result1, result2] = res;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>获取⼀个 Promise 列表中，第⼀个 resolve 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function wait(n) &#123;</span><br><span class="line">  return new Promise((res) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(1);</span><br><span class="line">      res(`等待了$&#123;n&#125;毫秒`);</span><br><span class="line">      console.log(2);</span><br><span class="line">    &#125;, n);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Promise.race([wait(1000), wait(500), wait(3000)]).then((res) =&gt; &#123;</span><br><span class="line">  console.log(&quot;Promise.race&quot;, res);   //等待了500毫秒</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>promise的语法糖           ⽤同步的⽅式，写异步代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function asyncFunction() &#123;</span><br><span class="line">     const res1 = await wait(1000);</span><br><span class="line">     console.log(res1);</span><br><span class="line">     const res2 = await wait(1000);</span><br><span class="line">     console.log(res2);</span><br><span class="line">     const res3 = await wait(1000);</span><br><span class="line">     console.log(res3);</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">function promiseFuction() &#123;</span><br><span class="line">     wait(1000)</span><br><span class="line">     .then((res1) =&gt; &#123;</span><br><span class="line">           console.log(res1);</span><br><span class="line">           return wait(1000);</span><br><span class="line">     &#125;)</span><br><span class="line">     .then((res2) =&gt; &#123;</span><br><span class="line">           console.log(res2);</span><br><span class="line">           return wait(1000);</span><br><span class="line">     &#125;)</span><br><span class="line">     .then((res3) =&gt; &#123;</span><br><span class="line">           console.log(res3);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="js值和引用"><a href="#js值和引用" class="headerlink" title="js值和引用"></a>js值和引用</h1><p>通过引⽤，可以访问到实时更新数据的最新值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = a;</span><br><span class="line">a = 2</span><br><span class="line">console.log(b) // 1</span><br><span class="line">// 将 a 地址（引⽤）获取到的值，复制⼀份，给到 b</span><br><span class="line">// a 修改后，b 不变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = &#123;value: 1&#125;;</span><br><span class="line">let b = a</span><br><span class="line">a.value = 2</span><br><span class="line">console.log(b.value) // 2</span><br><span class="line">//对象的值本身就是引⽤，a 和 b 引⽤同⼀对象</span><br></pre></td></tr></table></figure>

<h1 id="formData数据格式"><a href="#formData数据格式" class="headerlink" title="formData数据格式"></a>formData数据格式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// formData 初始化传⼊ form 表单节点</span><br><span class="line">const formData = new FormData(formNode);</span><br><span class="line">// 添加</span><br><span class="line">// formData.append(/*name,file/value*/);</span><br><span class="line">formData.append(&quot;a&quot;, &quot;&quot;);</span><br><span class="line">// 删除</span><br><span class="line">formData.delete(&quot;a&quot;);</span><br><span class="line">// 修改</span><br><span class="line">formData.set(&quot;a&quot;, &quot;new&quot;);</span><br><span class="line">// 获取</span><br><span class="line">formData.get(&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">对比</span><br><span class="line">// 初始化</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">// 添加</span><br><span class="line">obj.a = &quot;&quot;;</span><br><span class="line">// 删除</span><br><span class="line">delete obj.a;</span><br><span class="line">// 修改</span><br><span class="line">obj.a = &quot;new&quot;;</span><br><span class="line">// 获取</span><br><span class="line">obj.a;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 实现接口和解决跨域</title>
    <url>/2022/11/19/Node-js-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a><strong>npm</strong></h1><h2 id="npm是什么？"><a href="#npm是什么？" class="headerlink" title="npm是什么？"></a><strong>npm是什么？</strong></h2><blockquote>
<p>开发中一般不会什么功能都自己写，如何优雅的下载第三方模块呢?—npm</p>
<p><a href="https://docs.npmjs.com/cli/v8/using-npm">传送门：如何使用npm</a></p>
</blockquote>
<ul>
<li><strong>npm 是 管理（下载、卸载、发布）第三方模块的工具。</strong></li>
<li><code>npm</code>（node package manager）node 包管理工具。管理node包的工具。</li>
<li><strong>包</strong>是什么？包就是模块。（<strong>包约等于模块</strong>，一个包可以包括一个或多个模块）</li>
<li>npm这个工具，在安装 node 的时候，就已经安装到你的计算机中了。（捆绑安装）</li>
<li>命令行中执行： <code>npm -v</code> ，如果看到<strong>版本号</strong>，说明安装成功了。</li>
</ul>
<p><a href=""></a></p>
<h3 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么?"></a><strong>npm是什么?</strong></h3><p>刚才介绍了之后会经常使用的一个包管理工具-<code>npm</code></p>
<ul>
<li><code>npm</code>是什么?<ol>
<li>node的包管理工具</li>
<li>前端的第三方模块.也可以用它下载</li>
</ol>
</li>
<li>输入什么命令可以确认<code>npm</code>的版本?<ol>
<li><code>npm -v</code></li>
</ol>
</li>
</ul>
<h2 id="npm基本使用"><a href="#npm基本使用" class="headerlink" title="npm基本使用"></a><strong>npm基本使用</strong></h2><blockquote>
<p>上一节介绍了npm的概念，如何使用他呢?</p>
<p><a href="https://zhuanlan.zhihu.com/p/432578145">传送门:淘宝镜像站更换新域名啦</a></p>
</blockquote>
<p>淘宝镜像站 </p>
<p><a href="https://npmmirror.com/">npmmirror 中国镜像站</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置淘宝镜像，设置了之后，安装node模块，从国内镜像下载</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看npm地址</span></span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原 node.js在某些版本下，安装国内镜像可能或报错，还原回npm服务器</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过cnpm 安装模块 </span></span><br><span class="line"><span class="comment"># 或者使用cnpm  ==&gt; 以后使用 cnpm 安装，使用国内镜像站</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"><span class="comment"># 查看cnpm </span></span><br><span class="line">cnpm -v <span class="comment"># 以后可以使用 </span></span><br><span class="line"><span class="comment"># 安装新模块 </span></span><br><span class="line">cnpm install xxx </span><br></pre></td></tr></table></figure>

<h3 id="新建文件夹，初始化项目"><a href="#新建文件夹，初始化项目" class="headerlink" title="新建文件夹，初始化项目"></a>新建文件夹，初始化项目</h3><p><strong>基本步骤:</strong></p>
<ol>
<li><strong>初始化</strong>项目</li>
<li>下载需要的<strong>第三方</strong>模块</li>
</ol>
<p><strong>详细步骤：</strong></p>
<p>初始化命令的<strong>两种</strong>写法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment"># 然后一路回车</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p><code>npm init</code>默认会读取文件夹名作为<code>项目名 ==&gt; package name</code></p>
<ul>
<li><strong>package name</strong><ul>
<li>不能有<strong>中文</strong></li>
<li>不能有<strong>特殊符号</strong></li>
<li>不能和需要安装的<strong>第三方模块</strong>同名</li>
</ul>
</li>
</ul>
<ol>
<li>初始化之后，会在项目目录中生成 <code>package.json</code> 的文件。</li>
<li>初始化完毕之后就可以在<strong>当前文件夹</strong>安装第三方模块<ol>
<li>为了保证安装速度，建议执行这个命令</li>
<li>命令的作用是切换第三方模块的下载地址为<code>淘宝镜像</code></li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">建议在安装第三方模块之前，先执行如下命令。</span><br><span class="line">下面的命令只需要执行一次即可（不管以后重启vscode还是重启电脑，都不需要执行第二次）</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
</li>
<li>下载的命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常的下载安装</span></span><br><span class="line">npm install 模块名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写install为i</span></span><br><span class="line">npm i 模块名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性安装多个模块</span></span><br><span class="line">npm i 模块名 模块名 模块名</span><br><span class="line"><span class="comment"># 可以通过@版本号,不设置默认是最新</span></span><br><span class="line">npm i 模块名@版本号</span><br></pre></td></tr></table></figure>
</li>
<li>卸载的命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall 模块名</span><br><span class="line">npm un 模块名</span><br><span class="line">npm un 模块名 模块名 模块名</span><br></pre></td></tr></table></figure>
</li>
<li>测试<code>下载</code>和<code>卸载</code><ol>
<li><code>axios</code></li>
<li><code>dayjs</code></li>
</ol>
</li>
<li>观察下载之后项目中<strong>下列文件</strong>发生的变化<ol>
<li><code>package.json</code><ol>
<li>保存下载的模块信息</li>
</ol>
</li>
<li><code>package-lock.json</code></li>
<li><code>node_modules</code></li>
</ol>
</li>
</ol>
<h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6:"></a>Q6:</h3><ul>
<li><code>npm</code>初始化的项目名是否有要求？<ol>
<li>不能为中文,不能有特殊符号,大写字母⇒ 小写</li>
</ol>
</li>
<li>下载模块的命令是？<ol>
<li>npm i 模块名</li>
<li>npm i 模块名@版本号</li>
</ol>
</li>
<li>移除模块的命令是？<ol>
<li>npm un 模块名</li>
</ol>
</li>
</ul>
<h2 id="dayjs-基本使用"><a href="#dayjs-基本使用" class="headerlink" title="dayjs-基本使用"></a><strong>dayjs-基本使用</strong></h2><blockquote>
<p>上一节咱们下载了dayjs,咱们来看看这个库的作用是什么,并且来测试一下</p>
<p><a href="https://dayjs.fenxianglu.cn/">传送门:dayjs</a></p>
<p><a href="https://dayjs.fenxianglu.cn/category/parse.html#%E5%AD%97%E7%AC%A6%E4%B8%B2">传送门:解析规则</a></p>
</blockquote>
<h3 id="dayjs格式"><a href="#dayjs格式" class="headerlink" title="dayjs格式"></a>dayjs格式</h3><p><a href="https://dayjs.fenxianglu.cn/category/display.html#%E6%A0%BC%E5%BC%8F%E5%8C%96">https://dayjs.fenxianglu.cn/category/display.html#格式化</a></p>
<p>⇒ 注意大小写！！ 不能修改</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>();                                     <span class="comment">// 2020-09-08T13:42:32+08:00</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);                         <span class="comment">// 2020-09-08</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);                <span class="comment">// 2020-09-08 13:47:12</span></span><br><span class="line"><span class="title function_">dayjs</span>(<span class="number">1318781876406</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);   <span class="comment">// 2011-10-17 00:17:56</span></span><br></pre></td></tr></table></figure>

<h3 id="需求"><a href="#需求" class="headerlink" title="需求:"></a><strong>需求:</strong></h3><ol>
<li>根据文档确认用法并测试使用</li>
<li>将提供数据中的日期转为<code>2022-07-18 17:35:53</code>这种格式</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a><strong>步骤:</strong></h3><ol>
<li>参考<strong>文档</strong>,测试并使用</li>
<li>将如下时间戳转为<code>YYYY-MM-DD HH:mm:ss</code>这种格式 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1668640759762</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Q7-dayjs-基本使用"><a href="#Q7-dayjs-基本使用" class="headerlink" title="Q7:dayjs-基本使用"></a>Q7:<strong>dayjs-基本使用</strong></h3><p>这一小节咱们学习了日期格式化库-<code>dayjs</code>的基本使用:</p>
<ul>
<li>任何库的使用套路都是类似的:<ol>
<li>基于文档的示例-&gt;<strong>c+v</strong>运行</li>
<li>根据文档,传入不同的<strong>参数</strong></li>
</ol>
</li>
<li>如何进阶?<ol>
<li>基本使用:<strong>入门</strong></li>
<li>重度使用:<strong>熟练–&gt;精通→</strong> </li>
<li>修复<strong>框架/库</strong>的bug:<strong>开源框架贡献者</strong></li>
<li>实现<strong>框架/库</strong>:<strong>开源框架作者</strong></li>
</ol>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>模块化<ol>
<li>作用:<ol>
<li>大的–&gt;小的</li>
<li>小–&gt;组合到一起</li>
</ol>
</li>
<li>规范:<ol>
<li><strong>CommonJS</strong></li>
<li><strong>ESM</strong></li>
</ol>
</li>
<li>语法:<ol>
<li>module.exports—&gt;导出(暴露)</li>
<li>require()–&gt;导入</li>
<li>只能在<code>Node.js</code>中</li>
</ol>
</li>
</ol>
</li>
<li>npm:<ol>
<li>查看版本:<code>npm -v</code></li>
<li>下包:<ol>
<li><code>npm i 包名</code></li>
<li><code>npm i 包名@版本号</code></li>
</ol>
</li>
<li>用包<ol>
<li>跟着文档使用–<code>dayjs</code></li>
</ol>
</li>
<li>删包<ol>
<li><code>npm un 包名</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="package-json和package-lock-json的作用"><a href="#package-json和package-lock-json的作用" class="headerlink" title="package.json和package-lock.json的作用"></a><strong>package.json和package-lock.json的作用</strong></h2><blockquote>
<p>项目中中多出来的package.json和package-lock.json的作用是什么呢？</p>
<p><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">传送门:package.json</a></p>
<p><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json">传送门:package-lock.json</a></p>
<p><a href="https://juejin.cn/post/6870426598605062152">传送门:详解package.json和package-lock.json</a></p>
</blockquote>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><strong>package.json</strong></h3><p><strong>保存项目的信息:</strong></p>
<ol>
<li><code>name</code>：项目名</li>
<li><code>version</code>:项目版本</li>
<li><code>description</code>：项目描述</li>
<li><code>main</code>：项目入口</li>
<li><code>scripts</code>:<ol>
<li>示例中的:<code>test</code>可以通过<code>npm run test</code>执行</li>
</ol>
</li>
<li><code>author</code>:作者</li>
<li><code>license</code>:开源协议</li>
<li><code>dependencies</code>:项目中用到的第三方模块(依赖)</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;03&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dayjs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.11.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jquery&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.6.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a><strong>package-lock.json</strong></h3><ol>
<li>更为详细的第三方模块模块<ol>
<li>版本信息</li>
<li>甚至<strong>下载地址</strong></li>
<li>…</li>
</ol>
</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a><strong>实际应用</strong></h3><ol>
<li>共享的<code>node</code>项目一般会删除<code>node_modules</code></li>
<li>只要项目目录中有<code>package.json</code>说明项目是完整的</li>
<li><strong>项目根目录</strong>,执行<code>npm i</code>即可读取<code>package.json</code>中保存的<code>dependencies</code>(<strong>依赖信息</strong>),重新下载<ol>
<li>命令执行的目录和<code>package.json</code>同级</li>
</ol>
</li>
</ol>
<h3 id="PS-版本号"><a href="#PS-版本号" class="headerlink" title="PS.版本号"></a>PS.版本号</h3><p><strong>语义版本控制</strong></p>
<p>首先我们先来了解下依赖包的<strong>版本号的定义</strong></p>
<p>版本号由三部分组成：<code>major.minor.patch</code>，主版本号.次版本号.修补版本号。</p>
<p>例如：1.2.3，主要版本1，次要版本2，补丁3。</p>
<ul>
<li><code>补丁</code>中的更改表示不会破坏任何内容的错误修复。</li>
<li><code>次要版本</code>的更改表示不会破坏任何内容的新功能。</li>
<li><code>主要版本</code>的更改代表了一个破坏兼容性的大变化。 如果用户不适应主要版本更改，则内容将无法正常工作。</li>
</ul>
<p><strong>安装依赖包的版本如何指定</strong></p>
<p>相信大家都会经历过，我们安装一些依赖包的时候，版本号前面都会带 <code>^</code> 或者 <code>~</code> 的符号，这两个符号代表什么意思呢？</p>
<p><code>~</code> 会匹配最近的小版本依赖包，比如 ~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0</p>
<p><code>^</code> 会匹配最新的大版本依赖包，比如 ^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0</p>
<h3 id="Q8"><a href="#Q8" class="headerlink" title="Q8:"></a>Q8:</h3><ul>
<li>哪个命令会读取<code>package.json</code>中保存的依赖信息,并下载?<ol>
<li><code>npm i</code></li>
</ol>
</li>
<li>执行这个命令对<strong>路径是否</strong>有要求?<ol>
<li>和<code>package.json</code>同级</li>
</ol>
</li>
</ul>
<h2 id="全局模块"><a href="#全局模块" class="headerlink" title="全局模块"></a><strong>全局模块</strong></h2><blockquote>
<p>第三方模块除了项目中直接下载使用的模块以外,还有一种叫做全局模块的,咱们来认识一下,并且安装几个试试</p>
<p><a href="https://www.npmjs.com/package/nrm">传送门:nrm官网</a></p>
<p><a href="https://www.npmjs.com/package/serve">传送门:serve</a></p>
</blockquote>
<h3 id="和本地模块的差异"><a href="#和本地模块的差异" class="headerlink" title="和本地模块的差异"></a><strong>和本地模块的差异</strong></h3><ul>
<li>全局安装的模块，不能通过 <code>require()</code> 加载使用。</li>
<li>全局安装的模块，一般都是命令或者工具。</li>
</ul>
<h3 id="安装卸载命令"><a href="#安装卸载命令" class="headerlink" title="安装卸载命令"></a><strong>安装卸载命令</strong></h3><ul>
<li>安装命令（多一个 <code>g</code>）  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i 模块名 -g</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">npm i -g 模块名</span><br><span class="line"></span><br><span class="line"><span class="comment">### mac 系统如果安装不上，使用下面的命令提高权限</span></span><br><span class="line">sudo npm i -g 模块名</span><br></pre></td></tr></table></figure>
</li>
<li>卸载命令（也是多一个 <code>g</code>）  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm un 模块名 -g</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm uninstall 模块名 -g</span><br></pre></td></tr></table></figure>
</li>
<li>全局安装的模块，在系统盘（C盘）<ul>
<li>通过命令 <code>npm root -g</code> 可以查看全局安装路径</li>
</ul>
</li>
</ul>
<h3 id="nrm介绍"><a href="#nrm介绍" class="headerlink" title="nrm介绍"></a><strong><strong>nrm介绍</strong></strong></h3><p><code>nrm</code><br> 是作用是切换镜像源（模块下载地址；模块下载的网站）。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fcec1bb7-f2c5-4e2e-8c54-651c08e6559f/Untitled.png" alt="Untitled"></p>
<h3 id="nrm安装"><a href="#nrm安装" class="headerlink" title="nrm安装"></a><strong>nrm安装</strong></h3><ol>
<li>执行命令<ol>
<li>不需要记忆哪些模块需要<code>g</code>或者不需要</li>
<li>直接可以通过<a href="https://www.npmjs.com/package/nrm">官方文档</a>确认</li>
</ol>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i nrm -g （mac系统前面加 sudo）</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<code>nrm</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm --<span class="built_in">help</span>   <span class="comment"># 查看帮助</span></span><br><span class="line">nrm <span class="built_in">ls</span>    <span class="comment"># 查看全部可用的镜像源</span></span><br><span class="line">nrm <span class="built_in">test</span> <span class="comment"># 测试各个源的速度</span></span><br><span class="line">nrm use taobao  <span class="comment"># 切换到淘宝镜像</span></span><br><span class="line">nrm use npm  <span class="comment"># 切换到npm主站</span></span><br></pre></td></tr></table></figure>

<h3 id="Serve"><a href="#Serve" class="headerlink" title="Serve"></a>S<strong>erve</strong></h3><ol>
<li>功能和昨天自己编写的web服务器类似</li>
<li>参考文档<strong>安装+使用</strong></li>
<li>分别将<ol>
<li><strong>clock</strong>和<strong>数据可视化</strong></li>
<li>通过<code>serve</code>托管并测试访问</li>
</ol>
</li>
</ol>
<h3 id="常见错误及解决方案"><a href="#常见错误及解决方案" class="headerlink" title="常见错误及解决方案:"></a><strong>常见错误及解决方案:</strong></h3><ul>
<li><code>mac</code>安装:<ul>
<li>sudo npm i -g nrm</li>
<li>输入密码:</li>
</ul>
</li>
<li>运行 <code>nrm ls</code> 或者 <code>nrm use taobao</code> 等命令，如果报错如下：  “无法加载文件 C:………………….，<strong>因为在此系统上禁止运行脚本</strong>。…………….”<ul>
<li><strong>解决办法：</strong><ul>
<li><code>管理员</code>方式，打开命令行（powershell）窗口</li>
<li>执行 <code>set-ExecutionPolicy RemoteSigned;</code></li>
<li>在出现的选项中，输入 <code>A</code>，回车。即可。</li>
</ul>
</li>
</ul>
</li>
<li>如果报错如下: “<strong>无法将 nrm 识别为 cmdlet、函数、脚本文件或可运行程序的名称</strong>。xxxxxxxxxxx”<ul>
<li><strong>解决办法:</strong><ul>
<li>重启vscode，win7可能要重启电脑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><p>咱们安装并使用了几个全局模块:</p>
<ul>
<li>全局模块在安装命令是?比如安装<code>nrm</code>模块<ol>
<li><code>npm i nrm -g</code></li>
</ol>
</li>
<li>如何确认某个模块是全局模块还是本地模块？<ol>
<li>文档 - <a href="https://www.npmjs.com/package/serve">https://www.npmjs.com/package/serve</a></li>
</ol>
</li>
</ul>
<h1 id="写接口"><a href="#写接口" class="headerlink" title="写接口"></a><strong>写接口</strong></h1><blockquote>
<p>基于目前完成的内容,来实现一个返回数据的接口,并测试调用</p>
</blockquote>
<h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求:"></a><strong>需求:</strong></h3><ol>
<li>请求方法统一为<code>get</code></li>
<li><code>/api/news</code>返回新闻数据(日期转为<code>2022-07-18 17:35:53</code>)</li>
<li><code>/api/students</code>返回全部同学</li>
<li><code>/api/luckystar</code>返回随机的同学</li>
</ol>
<h3 id="基础模板"><a href="#基础模板" class="headerlink" title="基础模板:"></a><strong>基础模板:</strong></h3><ul>
<li>这部分内容直接<strong>c+v</strong></li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 web 服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8848</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;my server start work&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 为服务器实例绑定 request 事件，监听客户端的请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应的内容为JSON</span></span><br><span class="line"> response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json; charset=utf-8&#x27;</span>)</span><br><span class="line">  <span class="comment">// 不能直接响应 对象/数组 需要转为字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a><strong>分析:</strong></h3><ol>
<li><strong>接收</strong><ol>
<li>如何判断请求方法?<code>request.method</code></li>
<li>如何判断请求地址?<code>request.url</code></li>
</ol>
</li>
<li><strong>响应</strong><ol>
<li>如何获取对应的数据?<ol>
<li>调用封装的<code>db</code>数据模块的对应方法</li>
</ol>
</li>
<li>如何响应内容?<ol>
<li><code>response.end()</code></li>
</ol>
</li>
</ol>
</li>
<li><strong>逻辑:</strong><ol>
<li><code>/api/students</code><ol>
<li>返回<code>db.students()</code></li>
</ol>
</li>
<li><code>/api/luckystar</code><ol>
<li>返回<code>db.luckystar()</code></li>
</ol>
</li>
<li><code>/api/news</code><ol>
<li>转化<code>dayjs(时间戳).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试:"></a><strong>测试:</strong></h3><ol>
<li>运行本节代码<ol>
<li><code>node xxx.js</code></li>
</ol>
</li>
<li><strong>网页</strong>直接打开接口<ol>
<li><code>JSON</code>美化需要安装插件</li>
</ol>
</li>
<li>用接口测试工具测试</li>
<li><strong>写个页面</strong>来测试:<ol>
<li><strong>会报错</strong></li>
</ol>
 <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16135720-ec0e-4e66-ac72-c72d2a3780a0/Untitled.png" alt="Untitled"></li>
</ol>
<h3 id="写接口-1"><a href="#写接口-1" class="headerlink" title="写接口"></a><strong>写接口</strong></h3><p>咱们是前端开发工程师,虽然这一节咱们自己实现了几个简单的接口:</p>
<ul>
<li>工作中是否需要咱们写接口?<ol>
<li>不需要–后端</li>
</ol>
</li>
<li>本节写接口的目的是?<ol>
<li>理解后端的接口大概的工作流程, 核心就是请求过来了，搞到数据给到前端~</li>
</ol>
</li>
</ul>
<h1 id="同源-amp-跨域"><a href="#同源-amp-跨域" class="headerlink" title="同源&amp;跨域"></a><strong>同源&amp;跨域</strong></h1><h2 id="同源和同源策略"><a href="#同源和同源策略" class="headerlink" title="同源和同源策略"></a><strong>同源和同源策略</strong></h2><blockquote>
<p>刚才的接口之所以调用不了,原因就是因为打开的页面和接口不同源, 咱们来介绍一下什么是同源,以及浏览器的同源策略</p>
</blockquote>
<h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a><strong>同源</strong></h3><p>同源指的是<strong>两个URL</strong>地址具有相同的<strong>协议</strong>、<strong>主机</strong>、<strong>端口号</strong>。⇒ (协议，域名，端口)</p>
<p><strong>相对于</strong> <a href="http://www.test.com/index.html">http://www.test.com/index.html</a> 页面的 5 个同源检测结果：</p>
<h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略?"></a><strong>什么是同源策略?</strong></h3><p>同源策略（英文全称 <strong>Same origin policy</strong>）是<strong>浏览器</strong>提供的一个安全功能。<br>浏览器的同源策略规定：不允许非同源的 URL 之间进行资源的交互。</p>
<p><strong>地址1:</strong> 网页的URL</p>
<p>**地址2:**请求的资源地址(<strong>接口地址</strong>)</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d1cc3abb-f75b-4061-bba9-3f1b5bbb9c5d/Untitled.png" alt="Untitled"></p>
<h3 id="Q-1"><a href="#Q-1" class="headerlink" title="Q:"></a>Q:</h3><ul>
<li>同源指的是哪些相同？<ul>
<li>协议/主机/端口  ⇒ 协议，域名，端口号</li>
</ul>
</li>
<li>如果没有浏览器，还会有同源策略吗？<ul>
<li><strong>没有–&gt;浏览器的限制</strong></li>
</ul>
</li>
</ul>
<h2 id="跨域及主流跨域方法"><a href="#跨域及主流跨域方法" class="headerlink" title="跨域及主流跨域方法"></a><strong>跨域及主流跨域方法</strong></h2><blockquote>
<p>有了同源安全策略之后,只要2个不同源就会涉及到跨域</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a><strong>概念:</strong></h3><ul>
<li>同源指的是两个 URL 的<strong>协议、域名、端口号</strong>完全一致</li>
<li>反之，则是<strong>跨域</strong>。</li>
<li>浏览器的同源策略不允许非同源的 URL 之间进行资源的交互。例如：</li>
<li><strong>网页</strong>：<a href="http://www.test.com/index.html">http://www.test.com/index.html</a></li>
<li><strong>接口</strong>：<a href="http://www.api.com/userlist">http://www.api.com/userlist</a></li>
</ul>
<h3 id="浏览器对跨域请求的拦截过程"><a href="#浏览器对跨域请求的拦截过程" class="headerlink" title="浏览器对跨域请求的拦截过程?"></a><strong>浏览器对跨域请求的拦截过程?</strong></h3><p>浏览器允许发起跨域请求。但跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！示意图如下：</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d43f5fd-d06c-48a9-95c6-cb35ad00476f/Untitled.png" alt="Untitled"></p>
<h3 id="主流跨域方法"><a href="#主流跨域方法" class="headerlink" title="主流跨域方法"></a><strong>主流跨域方法</strong></h3><p><strong>代理服务器</strong> 和 <strong>CORS</strong> 是目前最为流行的<strong>实现跨域数据请求</strong>的两种技术方案。</p>
<ol>
<li><strong>CORS</strong> 是跨域的主流技术解决方案</li>
<li><strong>代理服务器</strong>跨域在后面vue课程中会讲到–<strong>Vue的第二个项目(人资)</strong></li>
<li>还有一些其他的跨域方案—<a href="https://juejin.cn/post/6844904126246027278">传送门</a></li>
</ol>
<h3 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E5%A6%82%E4%BD%95%E5%85%81%E8%AE%B8%E8%B7%A8%E6%BA%90%E8%AE%BF%E9%97%AE">如何允许跨源访问</a></h3><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a> 来允许跨源访问。CORS 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h2><blockquote>
<p>接下来咱们就来介绍一下什么是CORS,以及在Node.js中如何使用它</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">传送门:CORS</a>  ⇒ 跨源资源共享</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h3><ol>
<li><code>CORS</code> 是解决跨域数据请求的终极解决方案，全称是 <code>Cross-origin resource sharing</code>。</li>
<li><code>CORS</code> 技术需要<strong>浏览器</strong>和<strong>服务器</strong>同时支持</li>
</ol>
<ul>
<li>浏览器要<strong>支持</strong> CORS 功能（主流的浏览器全部支持，IE 不能低于 IE10）<ul>
<li><strong>前端开发者</strong>什么不都需要做</li>
</ul>
</li>
<li>服务器要<strong>开启</strong> CORS 功能（需要<strong>后端开发者</strong>为接口开启 CORS 功能）</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>服务器端通过 <code>Access-Control-Allow-Origin</code> 响应头，来告诉浏览器当前的 API 接口是否允许跨域请求。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f200ed71-55cf-4871-a50b-b3a90d6fc906/Untitled.png" alt="Untitled"></p>
<p>检查一下之前调用的接口是否有该<strong>响应头:</strong></p>
<h3 id="主要优势"><a href="#主要优势" class="headerlink" title="主要优势"></a><strong>主要优势</strong></h3><ol>
<li><strong>CORS</strong> 是真正的 Ajax 请求，支持 GET、POST、DELETE、PUT、PATCH 等这些常见的 Ajax 请求方式</li>
<li>只需要后端开启 <code>CORS</code> 功能即可，前端的代码无须做任何改动</li>
<li><code>Node.js</code>中可以通过设置如下的请求头<strong>允许跨域</strong>,添加到<strong>响应之前</strong></li>
</ol>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用总结</title>
    <url>/2022/11/20/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h4><p>Git 分布式版本控制系统     linus 2周 C语言写的</p>
<p>版本控制系统 version control system   ==&gt; VCS</p>
<p>作用： 代码存档备份，支持多人协作开发。</p>
<h4 id="版本控制系统的分类"><a href="#版本控制系统的分类" class="headerlink" title="版本控制系统的分类"></a>版本控制系统的分类</h4><ol>
<li>本地VCS</li>
<li>集中式VCS   ==&gt; SVN</li>
<li>分布式VCS   ==&gt; Git </li>
</ol>
<h4 id="Git-三个区域"><a href="#Git-三个区域" class="headerlink" title="Git 三个区域"></a>Git 三个区域</h4><ol>
<li>工作区 workspace   红色</li>
<li>暂存区  staged      绿色</li>
<li>Git仓库</li>
</ol>
<h4 id="git-bash里面不能ctrl-v-gt-右键-paste-粘贴"><a href="#git-bash里面不能ctrl-v-gt-右键-paste-粘贴" class="headerlink" title="git bash里面不能ctrl v ==&gt;  右键 paste 粘贴"></a>git bash里面不能ctrl v ==&gt;  右键 paste 粘贴</h4><h4 id="1-配置用户信息"><a href="#1-配置用户信息" class="headerlink" title="1. 配置用户信息"></a>1. 配置用户信息</h4><p>使用Git之前，第一步就是配置用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span>   <span class="comment"># user.name后面是空格!</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span>  <span class="comment"># 以后去到了公司，用的是公司给你配置的邮箱</span></span><br><span class="line">// 注意，空格不能少</span><br></pre></td></tr></table></figure>

<h4 id="2-查看配置信息"><a href="#2-查看配置信息" class="headerlink" title="2. 查看配置信息"></a>2. 查看配置信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list --global    <span class="comment">#--global --list 可以交换位置.</span></span><br></pre></td></tr></table></figure>

<h4 id="3-清除某个配置-–unset"><a href="#3-清除某个配置-–unset" class="headerlink" title="3. 清除某个配置 –unset"></a>3. 清除某个配置 –unset</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">unset</span> --global user.name  <span class="comment"># 一般用的是global</span></span><br></pre></td></tr></table></figure>

<h4 id="4-记录用户信息的位置"><a href="#4-记录用户信息的位置" class="headerlink" title="4. 记录用户信息的位置"></a>4. 记录用户信息的位置</h4><p>C ==&gt;  .gitconfig 文件 </p>
<hr>
<h4 id="1-新建git仓库"><a href="#1-新建git仓库" class="headerlink" title="1. 新建git仓库"></a>1. 新建git仓库</h4><ol>
<li>已经有了项目文件的情况下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在项目文件夹   右键 git bash here </span></span><br><span class="line"><span class="comment"># 进入项目文件</span></span><br><span class="line">git init  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="comment"># 进入某个文件夹</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接初始化一个空的项目仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init 新项目的名字 </span><br><span class="line"><span class="comment"># 会自动创建一个项目文件夹，并且在文件里面初始化git仓库</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>git clone 拉取本身存在的项目，拉取下来之后，项目里默认就会有一个仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 地址</span><br></pre></td></tr></table></figure>



<h4 id="2-查看文件状态"><a href="#2-查看文件状态" class="headerlink" title="2. 查看文件状态"></a>2. 查看文件状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status  <span class="comment">#</span></span><br><span class="line">git status --short  <span class="comment"># 简洁模式  ??表示文件未跟踪</span></span><br><span class="line">git status -s   <span class="comment"># 简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决中文乱码问题</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-跟踪新的文件"><a href="#3-跟踪新的文件" class="headerlink" title="3. 跟踪新的文件"></a>3. 跟踪新的文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. </span></span><br><span class="line">git add 文件名字 <span class="comment"># 把未跟踪的文件纳入git管理， 默认会放到暂存区。</span></span><br><span class="line"></span><br><span class="line">git add .  <span class="comment"># 一次性的将所有文件纳入git管理  ===&gt; 以后会用的很多</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clear清屏 </span></span><br><span class="line">U:未跟踪的文件</span><br><span class="line"></span><br><span class="line">??: 未跟踪的文件</span><br><span class="line">A:新跟踪的文件，并且放到了暂存区。、</span><br><span class="line">M:已修改的文件</span><br><span class="line"></span><br><span class="line">// 颜色  红色   ===&gt; 工作区    绿色  ===&gt; 暂存区</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将已修改的文件添加到暂存区。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-提交更新"><a href="#4-提交更新" class="headerlink" title="4. 提交更新"></a>4. 提交更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交之前，我们需要把已修改的文件全部放到暂存区  git add . </span></span><br><span class="line">git commit -m <span class="string">&quot;本次修改的描述信息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过暂存区直接提交 （不用输入 git add）</span></span><br><span class="line"><span class="comment"># 前提是 已经跟踪提交过, 需要先提交一次文件</span></span><br><span class="line">git commit -a -m <span class="string">&quot;描述&quot;</span></span><br><span class="line">git commit -am <span class="string">&quot;描述&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-查看历史提交信息"><a href="#5-查看历史提交信息" class="headerlink" title="5. 查看历史提交信息"></a>5. 查看历史提交信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">git <span class="built_in">log</span> -2 <span class="comment"># 查看两条</span></span><br><span class="line">git <span class="built_in">log</span> --oneline   <span class="comment">#一行显示 精简模式  重点记住 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个commit 就是一个版本记录   历史记录前面的7个字符就是   CommitID</span></span><br></pre></td></tr></table></figure>

<h4 id="6-回退到指定的版本"><a href="#6-回退到指定的版本" class="headerlink" title="6. 回退到指定的版本"></a>6. 回退到指定的版本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先查看历史记录</span></span><br><span class="line">git <span class="built_in">log</span> --oneline  可以得到commitID</span><br><span class="line"><span class="comment"># 使用reset回退版本 </span></span><br><span class="line">git reset --hard commitID</span><br><span class="line"><span class="comment"># 可以再查看一下记录</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<h4 id="7-将暂存区的文件移到工作区"><a href="#7-将暂存区的文件移到工作区" class="headerlink" title="7. 将暂存区的文件移到工作区"></a>7. 将暂存区的文件移到工作区</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要提交一次 git commit </span></span><br><span class="line">git reset HEAD 文件名</span><br><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>



<h4 id="8-将git仓库中的文件放到工作区，并且让文件处于未跟踪状态"><a href="#8-将git仓库中的文件放到工作区，并且让文件处于未跟踪状态" class="headerlink" title="8. 将git仓库中的文件放到工作区，并且让文件处于未跟踪状态"></a>8. 将git仓库中的文件放到工作区，并且让文件处于未跟踪状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached index.html </span><br><span class="line"><span class="comment"># 将文件从仓库中删除，变为未跟踪状态</span></span><br></pre></td></tr></table></figure>



<h4 id="9-将不需要管理的文件忽略"><a href="#9-将不需要管理的文件忽略" class="headerlink" title="9. 将不需要管理的文件忽略"></a>9. 将不需要管理的文件忽略</h4><ul>
<li>.gitignore 只忽略未跟踪的文件。如果文件已经纳入了git管理，则gitignore 配置无效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前提是 未跟踪的文件才能添加到gitignore生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 将已经在仓库中的文件变为 未跟踪状</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached .   <span class="comment">#一次性把所有仓库中的文件都拿出来，都变为未跟踪的状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重新添加，应用gitignore配置</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.提交一下这次更新</span></span><br><span class="line">git commit -m <span class="string">&quot;更新gitignore&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="10-VSCode配置git-bash"><a href="#10-VSCode配置git-bash" class="headerlink" title="10 VSCode配置git bash"></a>10 VSCode配置git bash</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ctrl + j  </span></span><br><span class="line"><span class="comment">// cmd + j</span></span><br><span class="line"></span><br><span class="line">Ctrl + shift + p  ==&gt; 输入 JSON </span><br><span class="line"></span><br><span class="line"><span class="comment">// where git </span></span><br><span class="line"><span class="comment">// path 修改为Git bash的路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;terminal.integrated.profiles.windows&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;PowerShell -NoProfile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PowerShell&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-NoProfile&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Git-Bash&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Program Files\\Git\\bin\\bash.exe&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git-Bash&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git 三个区域 </span></span><br><span class="line">工作区  暂存区  git仓库</span><br><span class="line"><span class="comment"># git 三个状态  </span></span><br><span class="line">已修改  已暂存  已提交</span><br><span class="line"><span class="comment"># 文件的四个状态</span></span><br><span class="line">未纳入git管理   1. 未跟踪 Untracked</span><br><span class="line"></span><br><span class="line">已纳入git管理   1. 未修改 Unmodified</span><br><span class="line">			  2. 已修改 modified </span><br><span class="line">              3. 已暂存  staged</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 三大模块</title>
    <url>/2022/11/19/Node-js-%E4%B8%89%E5%A4%A7%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="Node-js是什么？"><a href="#Node-js是什么？" class="headerlink" title="Node.js是什么？"></a>Node.js是什么？</h2><blockquote>
<p>Node.js is an open-source, cross-platform JavaScript runtime environment.</p>
</blockquote>
<ul>
<li>定义  <strong>Node.js®是一个开源、跨平台的JavaScript运行时环境。</strong>  ⇒ Node.js 是一个基于 <code>Chrome V8 引擎</code>的<strong>JavaScript运行时环境</strong>。</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8fcd203-ea3c-4675-bb84-47247c44c0ef/Untitled.png" alt="Untitled"></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d3263f51-7829-4182-a2ef-e760260504f4/Untitled.png" alt="Untitled"></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/39a1178e-3d5e-42d1-bd8f-17d183943feb/Untitled.png" alt="Untitled"></p>
<ul>
<li><strong>Node.js 能做什么？</strong><ol>
<li>后端Web服务器开发/写接口</li>
<li>写爬虫</li>
<li>写应用程序</li>
<li>脚手架命令行工具</li>
</ol>
</li>
</ul>
<h3 id="Node-js-发展历史"><a href="#Node-js-发展历史" class="headerlink" title="Node.js 发展历史"></a>Node.js 发展历史</h3><p>2008年 V8 引擎 随着 Chrome浏览器问世</p>
<p><code>Node.js发布于2009年5月</code>，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型，  让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。</p>
<p><strong>如果只有ECMAScript？</strong> </p>
<ol>
<li>不能操作DOM， 不能监听click事件，不能发送ajax请求（浏览器提供的）</li>
<li>不能处理HTTP请求，不能操作文件</li>
</ol>
<h2 id="Node-js能干啥？"><a href="#Node-js能干啥？" class="headerlink" title="Node.js能干啥？"></a><strong><strong>Node.js能干啥？</strong></strong></h2><p><code>Node.js</code> 作为一个 <code>JavaScript</code> 的运行环境，仅仅提供了基础的功能和 <code>API</code>。然而，基于 <code>Node.js</code> 提供的这些基础功能，很多强大 的工具和框架如雨后春笋，层出不穷，所以学会了 <code>Node.js</code> ，可以让<strong>前端程序员胜任更多的工作和岗位</strong>！</p>
<ul>
<li>基于 <strong>Express/Koa</strong> 框架(<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a>)，可以快速构建 Web 应用–&gt;<code>java</code></li>
<li>基于 <strong>Electron</strong> 框架(<a href="https://electronjs.org/">https://electronjs.org/</a>)，可以构建<strong>跨平台</strong>的桌面应用–&gt;<code>安装,才可以使用的,开发一次,多平台运行</code></li>
<li>基于 <strong>Crawler</strong> 框架(<a href="https://www.npmjs.com/package/crawler">https://www.npmjs.com/package/crawler</a>)，可以快速开发<strong>爬虫应用</strong>-&gt;<code>很</code></li>
<li>读写和操作<strong>数据库</strong>、创建实用的命令行工具<strong>辅助前端开发</strong>（后续框架中会一直使用的）</li>
<li><code>etc</code>…</li>
</ul>
<p>总之，<code>Node.js</code> 是大前端时代的“大宝剑”，有了 <code>Node.js</code> 这个超级 <code>buff</code> 的加持，前端程序员的行业竞争力会越来越强！</p>
<h3 id="Node-js下载安装"><a href="#Node-js下载安装" class="headerlink" title="Node.js下载安装"></a>Node.js下载安装</h3><blockquote>
<p><a href="https://nodejs.org/en/">Node官网</a>  ⇒ 推荐 LTS  （Long  Term Support）</p>
</blockquote>
<p><a href="https://nodejs.org/zh-cn/">Node.js</a></p>
<blockquote>
<p>01 首页</p>
</blockquote>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c001f9d-9d22-410a-aa53-f90fe3439465/Untitled.png" alt="Untitled"></p>
<blockquote>
<p>02 下载</p>
</blockquote>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4be22045-2c91-4a9d-89b8-b87f9d5e79b6/Untitled.png" alt="Untitled"></p>
<blockquote>
<p><strong>安装</strong></p>
</blockquote>
<ul>
<li>安装就一直下一步就行了哈， 不要在中文文件夹目录下安装，默认选项不用修改，一直next</li>
</ul>
<ol>
<li>安装的过程全程<code>下一步</code><ol>
<li>不要改任何设置</li>
</ol>
</li>
<li><strong>注意！！！！！：</strong><ol>
<li>如非必要不要更改安装路径</li>
</ol>
</li>
</ol>
<p><strong>查看是否安装好</strong></p>
<blockquote>
<p>windows ⇒ 按 <code>win + R</code> ,  输入<code>cmd</code> ，打开终端 terminal 窗口, 执行下列命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v </span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">node --version</span><br><span class="line"><span class="comment"># 显示版本号，就说明安装好了</span></span><br><span class="line"></span><br><span class="line">如果看不到：</span><br><span class="line">关闭所有打开的终端，重新打开</span><br></pre></td></tr></table></figure>

<h3 id="常见的终端窗口"><a href="#常见的终端窗口" class="headerlink" title="常见的终端窗口"></a>常见的终端窗口</h3><ul>
<li><strong>Windows</strong><ul>
<li>自带 <strong>cmd</strong> （在文件夹路径位置，输入cmd，回车）</li>
<li>自带 <strong>powershell</strong> （在文件夹路径位置，输入powershell ，回车）</li>
<li>商店下载 Windows Terminal</li>
<li>安装git之后，点 git bash here</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="如何使用Node-js-运行-Javascript-代码"><a href="#如何使用Node-js-运行-Javascript-代码" class="headerlink" title="如何使用Node.js 运行 Javascript 代码"></a>如何使用Node.js 运行 Javascript 代码</h3><p>新建一个文件 报错 touch “文件名”</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2375e5a2-5f41-46d2-b07c-badf0cf30b9e/Untitled.png" alt="Untitled"></p>
<p>windows不支持touch命令 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">npm install touch-cli -g  全局安装后可以使用</span><br></pre></td></tr></table></figure>

<p><strong>方法一，终端里写代码</strong> （了解）</p>
<blockquote>
<p>cmd中输入node</p>
</blockquote>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fab5db3-2d44-42d2-aa24-8e95e3cd3e9d/Untitled.png" alt="Untitled"></p>
<ol>
<li>打开终端窗口:</li>
<li>输入<code>node</code>回车</li>
<li>输入语法正确的<code>JS</code>代码,比如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;感觉自己萌萌哒!&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li>点击回车</li>
<li><code>ctrl+c</code>退出窗口</li>
<li><strong>思考：</strong><ol>
<li>如果代码很复杂用这种方式你是否快乐？</li>
</ol>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;wakaka&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line"><span class="comment">// 按住Ctrl + 按两次C</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二，使用node执行js文件（掌握）</strong></p>
<ol>
<li><strong>编写语法正确的<code>.js</code>文件</strong><ol>
<li>除了<code>Bom</code>和<code>Dom</code>，基本都可以写</li>
<li><code>console.log</code>,<code>setTimeout</code>这些也提供了</li>
<li><strong>注意！！！！：</strong>是<code>.js</code>文件</li>
</ol>
</li>
<li>在<code>.js</code>文件所在文件夹打开任意终端<ol>
<li><code>vscode 自带终端</code></li>
<li><code>cmd</code></li>
<li><code>power shell</code></li>
<li><code>git bash</code></li>
<li>….</li>
</ol>
</li>
<li>输入命令<code>node xx.js</code><ol>
<li><code>xx.js</code>是需要执行的文件名</li>
<li>中间有<strong>空格</strong></li>
</ol>
</li>
</ol>
<h3 id="补充：指定文件夹打开终端的方法："><a href="#补充：指定文件夹打开终端的方法：" class="headerlink" title="补充：指定文件夹打开终端的方法："></a><strong>补充：指定文件夹打开终端的方法：</strong></h3><ol>
<li><code>cmd</code>:<ol>
<li>文件夹路径处输入<code>cmd</code>，回车</li>
</ol>
</li>
<li><code>powershell</code><ol>
<li>在文件夹路径处输入<code>powershell</code>,回车</li>
</ol>
</li>
<li><code>git bash</code><ol>
<li>文件夹中直接鼠标右键<code>git bash here</code>即可</li>
</ol>
</li>
<li><code>vscode</code><ol>
<li>在左侧资源管理中选中文件并右键</li>
<li>选择:<code>在集成终端中打开</code></li>
<li>**ctrl+`**可以快速切换终端的开关</li>
<li><strong>注意：</strong><ol>
<li>初期<strong>不建议开多个</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="补充-终端使用技巧"><a href="#补充-终端使用技巧" class="headerlink" title="补充-终端使用技巧"></a><strong>补充-终端使用技巧</strong></h3><ol>
<li>方向键<code>↑</code>,<code>↓</code>可以切换历史命令</li>
<li>按<code>tab</code>可以自动补全</li>
<li><code>cls</code>或者<code>clear</code>可以清屏</li>
<li><code>cd ../</code>,<code>cd 文件夹名</code>… 路径切换</li>
<li>….</li>
</ol>
<h3 id="Q小结"><a href="#Q小结" class="headerlink" title="Q小结"></a>Q小结</h3><blockquote>
<p>刚才演示了如何使用<code>Node.js</code>:</p>
</blockquote>
<ul>
<li>演示的两种方法中建议使用哪一种?<ol>
<li><code>node xxx.js</code></li>
</ol>
</li>
<li>电脑上有那么多的终端工具，建议用哪一种？<ol>
<li>随便, 选一个自己喜欢的   </li>
<li>=⇒ mac  推荐 iterm2  =⇒ oh my zsh</li>
</ol>
</li>
</ul>
<h2 id="global模块"><a href="#global模块" class="headerlink" title="global模块"></a><strong><strong>global模块</strong></strong></h2><p>类似于<code>window</code>对象,node中也有全局模块,在使用时不需要引入，直接使用</p>
<ol>
<li><a href="https://nodejs.org/api/modules.html#__dirname">传送门:__dirname</a></li>
<li><a href="https://nodejs.org/dist/latest-v16.x/docs/api/modules.html#__filename">传送门:__filename</a></li>
<li><a href="https://nodejs.org/dist/latest-v16.x/docs/api/console.html">传送门:console</a></li>
<li><a href="https://nodejs.org/dist/latest-v16.x/docs/api/globals.html#setintervalcallback-delay-args">传送门:setTimeout</a></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * window 浏览器中的全局对象</span></span><br><span class="line"><span class="comment">  * global nodejs中的全局对象</span></span><br><span class="line"><span class="comment">  * 注意 : node里面使用 global里面的变量,不需要引入</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1. console.log()  打印</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. setTimeout 和setInterval ，延时器和定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块作用域下的属性 </span></span><br><span class="line">  <span class="comment">//3. __dirname  当前文件夹的绝对路径</span></span><br><span class="line">  <span class="comment">//4. __filename 当前文件的完整路径, 包含当前文件</span></span><br><span class="line">  <span class="comment">//从当前所在磁盘盘符一直到当前文件夹的路径</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(__filename);</span><br></pre></td></tr></table></figure>

<h2 id="FS模块"><a href="#FS模块" class="headerlink" title="FS模块"></a><strong><strong>FS模块</strong></strong></h2><p><code>fs</code>模块是<code>nodejs</code>中最常用的一个模块，fs模块的方法非常多,今天咱们了解2个即可</p>
<p>文档地址：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
<p><strong>注意：</strong></p>
<ol>
<li>除了global模块中的内容可以直接使用，其他模块都是需要加载的。</li>
<li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似于浏览器中 script src=&quot;xx&quot;</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a><strong>读取文件</strong></h3><blockquote>
<p>首先是读取文件的方法</p>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fsreadfilesyncpath-options">传送门:readFileSync</a></p>
</blockquote>
<p>⇒ 中文  </p>
<p><a href="https://www.nodeapp.cn/fs.html#fs_fs_readfilesync_path_options">文件系统 | Node.js 中文文档 | Node.js 中文网</a></p>
<p><code>fs</code>模块提供的读取文件的方法有很多种,咱们来学习这种同步的读取写法</p>
<p>⇒ 同步读取文件</p>
<p><strong>写法1:</strong> 不考虑异常</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1 不给编码格式 返回buffer对象</span></span><br><span class="line"><span class="comment">// const res = fs.readFileSync(&#x27;./info/a.txt&#x27;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res:&#x27;</span>, res)</span><br><span class="line"><span class="comment">// 写法2 给编码格式</span></span><br><span class="line"><span class="keyword">const</span> res2 = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./info/a.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res2:&#x27;</span>, res2)</span><br></pre></td></tr></table></figure>

<p>**写法2:**可以通过<code>try-catch</code>捕获</p>
<p>⇒ Buffer 缓冲对象</p>
<p>JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>
<p><a href="https://www.runoob.com/nodejs/nodejs-buffer.html">https://www.runoob.com/nodejs/nodejs-buffer.htm</a>l</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="title class_">Buffer</span>对象是<span class="title class_">Nodejs</span>用于处理二进制数据的。</span><br><span class="line"><span class="number">2.</span> 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。</span><br><span class="line"><span class="number">3.</span> 所以读取任意的文件，返回的结果都是二进制数据，即<span class="title class_">Buffer</span>对象</span><br><span class="line"><span class="number">4.</span> <span class="title class_">Buffer</span>对象可以调用<span class="title function_">toString</span>()方法转换成字符串。</span><br></pre></td></tr></table></figure>

<h3 id="Q-小结"><a href="#Q-小结" class="headerlink" title="Q:小结"></a>Q:小结</h3><ul>
<li><code>readFileSync</code>是哪个模块点出来的?<ol>
<li><code>fs</code></li>
</ol>
</li>
<li>不设置编码格式返回的是什么?<ol>
<li><strong>用进制的方式表示的Buffer数据</strong></li>
</ol>
</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>接下来咱们来学习如何写文件</p>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fswritefilesyncfile-data-options">传送门:writeFileSync</a></p>
<p><a href="https://www.nodeapp.cn/fs.html#fs_fs_writefilesync_file_data_options">文件系统 | Node.js 中文文档 | Node.js 中文网</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1 路径</span></span><br><span class="line"><span class="comment">// 参数2 内容</span></span><br><span class="line"><span class="comment">// 可以使用try-catch捕获异常</span></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./info/a.txt&#x27;</span>,<span class="string">&#x27;内容&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 基本使用</span><br><span class="line"><span class="number">2.</span> 文件不存在</span><br><span class="line"><span class="number">3.</span> 文件夹和文件均不存在</span><br></pre></td></tr></table></figure>

<h3 id="Q小结-1"><a href="#Q小结-1" class="headerlink" title="Q小结"></a>Q小结</h3><p>刚才咱们演示了如何写文件:</p>
<ul>
<li><code>writeFileSync</code>是哪个模块点出来的?<ol>
<li><code>fs</code></li>
</ol>
</li>
<li>文件不存在是否会报错?<ol>
<li>不会–&gt;创建</li>
</ol>
</li>
<li>文件夹不存在是否会报错?<ol>
<li>报错–&gt;找不到</li>
</ol>
</li>
</ul>
<h3 id="练习-成绩统计"><a href="#练习-成绩统计" class="headerlink" title="练习 - 成绩统计"></a>练习 <strong><strong>- 成绩统计</strong></strong></h3><blockquote>
<p>结合刚刚学习的内容,咱们来完成一个成绩统计的案例</p>
</blockquote>
<p><strong>需求</strong></p>
<ol>
<li>读取<code>成绩.txt</code>中的成绩并进行累加</li>
<li>将累加的结果保存到,<code>总成绩.txt</code>中</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">小明=<span class="number">98</span>,小红=<span class="number">68</span>,小黑=<span class="number">88</span>,小绿=<span class="number">77</span>,小王=<span class="number">59</span>,小白=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a><strong>步骤:</strong></h3><ol>
<li>读取数据<ol>
<li><code>fs.readFileSync</code></li>
</ol>
</li>
<li>转换数据格式<ol>
<li>,—&gt;分隔 <code>split</code>–字符串–&gt;数组</li>
<li><code>=</code>-&gt;<code>split</code>获取到数值</li>
</ol>
</li>
<li>累加并保存<ol>
<li>累加</li>
<li><code>fs.writeFileSync</code></li>
</ol>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 读取数据</span></span><br><span class="line"><span class="keyword">const</span> scope = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./score/成绩.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(&#x27;scope:&#x27;, scope)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.转换数据格式</span></span><br><span class="line"><span class="comment">// 根据,切换为 数组</span></span><br><span class="line"><span class="keyword">const</span> arr = scope.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">// 基于数组 获取每一项中的数字</span></span><br><span class="line"><span class="keyword">const</span> numArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(v.split(&#x27;=&#x27;))</span></span><br><span class="line">  <span class="comment">// 切割之后索引为1的值 str</span></span><br><span class="line">  <span class="comment">// +str--&gt;数字</span></span><br><span class="line">  <span class="keyword">return</span> +v.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(&#x27;numArr:&#x27;, numArr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.累加+保存</span></span><br><span class="line"><span class="keyword">const</span> total = numArr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> pre + cur</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// console.log(&#x27;total:&#x27;, total)</span></span><br><span class="line"><span class="comment">// 不允许直接写入数字 转为 字符串</span></span><br><span class="line"><span class="comment">// 数字+&#x27;&#x27;--&gt;string</span></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./score/总成绩.txt&#x27;</span>, total + <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ol>
<li><code>Node.js</code><ol>
<li><code>JavaScript</code>的运行时环境</li>
<li>它也可以解析<code>js</code>代码</li>
</ol>
</li>
<li>如何用<code>Node.js</code>解析<code>js</code><ol>
<li><code>node 文件名.js</code></li>
</ol>
</li>
<li><code>fs</code>文件模块<ol>
<li><code>const fs = require(&#39;fs&#39;)</code></li>
<li>读取:<code>fs.readFileSync</code></li>
<li>写入:<code>fs.writeFileSync</code></li>
<li>成绩统计的案例</li>
</ol>
</li>
<li><code>reduce</code></li>
</ol>
<h2 id="路径动态拼接的问题"><a href="#路径动态拼接的问题" class="headerlink" title="路径动态拼接的问题"></a><strong><strong>路径动态拼接的问题</strong></strong></h2><blockquote>
<p>目前为止咱们终端所处路径和<code>.js</code>所在的路径相同,如果不相同呢?</p>
</blockquote>
<p>⇒ 代码在运行的时候，会以执行<code>node</code> 命令时所处的目录(<strong>小黑窗</strong>)，<strong>动态拼接出（加上文件内部写的路径）</strong>被操作文件的完整路径。</p>
<h3 id="复现问题步骤"><a href="#复现问题步骤" class="headerlink" title="复现问题步骤:"></a><strong>复现问题步骤:</strong></h3><ol>
<li><code>node</code>切换到和<code>.js</code>不同级的目录</li>
<li>运用相对路径执行<code>.js</code>文件 <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/638dc9b0-5b91-4da0-85cc-1385acfc4cc8/Untitled.png" alt="Untitled"></li>
<li>测试<strong>基本逻辑</strong>的<code>js</code></li>
<li>测试上一节<code>demo</code>中的<code>.js</code></li>
<li>测试使用<strong>绝对路径</strong></li>
</ol>
<h3 id="路径动态拼接的问题-1"><a href="#路径动态拼接的问题-1" class="headerlink" title="路径动态拼接的问题"></a><strong>路径动态拼接的问题</strong></h3><p>这一节咱们演示了<strong>路径动态</strong>拼接的问题:</p>
<ol>
<li>执行<code>node</code>命令时,代码中的相对路径会和<strong>哪个路径</strong>动态拼接?<ol>
<li>会和<strong>终端中的路径动态</strong>的拼接</li>
<li>不是和<code>执行的js</code>动态拼接</li>
</ol>
</li>
<li>相对路径不靠谱,如何解决?<ol>
<li><strong>绝对路径</strong></li>
</ol>
</li>
</ol>
<h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a><strong>path模块</strong></h2><blockquote>
<p>Node.js提供的处理路径的模块path,提供了很多处理路径的方法和属性,他也是一个内置模块</p>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/path.html">传送门:path模块</a></p>
</blockquote>
<p>类似于<code>FS</code>模块,使用时需要先导入</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>方法很多,咱们了解其中的1个即可</p>
<ol>
<li><code>join</code></li>
</ol>
<h3 id="拼接-join"><a href="#拼接-join" class="headerlink" title="拼接-join"></a><strong>拼接-join</strong></h3><blockquote>
<p>首先是join方法,他可以把多个路径片段拼接为完整的路径字符串,并且格式会和当前所在的操作系统一致</p>
<p><a href="https://www.nodeapp.cn/path.html#path_path_join_paths">传送门</a></p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><ol>
<li>基于文档确认语法</li>
</ol>
<h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a><strong>测试步骤</strong></h3><ol>
<li>基于文档确认语法并进行<strong>测试</strong></li>
<li>测试通过之后:<ol>
<li>使用<strong>绝对路径</strong>来<strong>读取</strong>文件</li>
</ol>
</li>
</ol>
<h3 id="拼接-join方法"><a href="#拼接-join方法" class="headerlink" title="拼接-join方法"></a><strong>拼接-join方法</strong></h3><p>这一节咱们演示了如何通过<code>join</code>方法拼接路径:</p>
<ol>
<li>利用<code>join</code>方法拼接路径和直接自己拼接的区别是?<ol>
<li>join更简单</li>
<li>根据具体的设备,生成不同的路径—&gt;<strong>灵活</strong></li>
</ol>
</li>
<li>不同操作系统拼接出来的路径是否相同?<ol>
<li><code>\</code>-<code>/</code></li>
</ol>
</li>
</ol>
<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a><strong>http模块</strong></h2><blockquote>
<p>今天的最后我们来学习http模块,并且结合他来开发一个静态资源服务器</p>
</blockquote>
<blockquote>
<p>为了更好的理解后续的代码,咱们来学习一些预备的知识</p>
</blockquote>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a><strong>前置知识</strong></h3><p><strong>当我们在浏览器中输入了<a href="notion://www.notion.so/www.baidu.com">www.baidu.com</a>的时候,发生了什么?</strong></p>
<ul>
<li>ip地址 域名 端口三者之间的关系?<ul>
<li><strong>ip地址:</strong><ul>
<li>任何一台设备(计算机, 手机, …)想要接入到网络中(互联网,局域网)，就会被分配一个<strong>唯一的ip地址</strong></li>
<li>通过这个<code>ip</code>地址就能找到这台设备</li>
</ul>
</li>
<li><strong>域名:</strong><ul>
<li>比如 <a href="notion://www.notion.so/www.jd.com">www.jd.com</a> 就是域名 ，方便记忆</li>
<li>我们购买了<strong>服务器</strong>之后, 服务器会有一个<strong>IP</strong>地址, 我们可以通过<strong>域名解析</strong>让域名指向当前IP</li>
<li>域名和ip地址绑定后，通过域名就可以找到对应的<strong>ip地址</strong>, 从而访问到该服务器</li>
</ul>
</li>
<li><strong>端口:</strong><ul>
<li>端口是计算机和外界通讯的<strong>虚拟通道</strong></li>
<li>一台计算机能运行很多程序, 一般一个程序会占用<strong>一个</strong>或者<strong>多个</strong>端口</li>
<li>http协议的默认端口是<strong>80</strong></li>
<li>https协议的默认端口是<strong>443</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fffa8b74-8055-4e76-8e8e-485d7b9cc064/Untitled.png" alt="Untitled"></p>
<ol>
<li>根据相关域名, 去查询<code>dns</code>服务器,得到对应的ip地址</li>
<li>根据<code>IP</code>地址, 找到对应的计算机</li>
<li>根据<code>端口</code>找到对应的服务器程序</li>
<li>根据<code>url</code>请求具体的信息</li>
<li>服务器根据上述信息<strong>发送请求</strong></li>
<li>浏览器<strong>接收</strong>到了服务器的响应, 把结果响应出来</li>
</ol>
<h3 id="什么是http模块"><a href="#什么是http模块" class="headerlink" title="什么是http模块"></a><strong>什么是http模块</strong></h3><blockquote>
<p>http也是内置模块, Node.js 官方提供的、用来创建web 服务器的模块。</p>
</blockquote>
<p>它提供了一系列的方法和属性,让开发者(咱们)可以用代码来创建<strong>服务器</strong>,接收<strong>请求</strong>及响应<strong>内容</strong>例如：</p>
<p>⚫ <code>http.createServer()</code> 方法，用来创建一个<code>web</code> 服务器，从而对外提供web 资源</p>
<p>如果要在 <code>Node.js</code>的代码中使用 <code>http</code> 模块，则需要先<strong>导入它</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="前置知识及http模块介绍"><a href="#前置知识及http模块介绍" class="headerlink" title="前置知识及http模块介绍"></a><strong>前置知识及http模块介绍</strong></h3><p>这一节咱们介绍了请求web服务器的基本流程,及<code>Node</code>自带的<code>http</code>模块:</p>
<ul>
<li><code>url</code>地址经由什么解析为<code>ip</code>地址?<ol>
<li>DNS解析服务器</li>
</ol>
</li>
<li><code>http</code>协议的默认端口是?<ol>
<li>80</li>
</ol>
</li>
</ul>
<p><code>node</code>提供了<code>http</code>模块可以让开发者创建<code>web</code>服务器</p>
<h3 id="创建最基本的web服务器"><a href="#创建最基本的web服务器" class="headerlink" title="创建最基本的web服务器"></a><strong>创建最基本的web服务器</strong></h3><blockquote>
<p>接下来咱们基于官方的示例代码创建基本的web服务器</p>
<p><a href="http://nodejs.cn/api-v16/http.html">传送门:http模块</a></p>
<p><a href="http://nodejs.cn/learn#nodejs-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A4%BA%E4%BE%8B">传送门:Node.js应用程序示例</a></p>
</blockquote>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a><strong>步骤</strong></h3><ol>
<li>导入 <code>http</code> 模块</li>
<li>创建 <code>web</code> 服务器实例</li>
<li>启动服务器</li>
<li>为服务器实例绑定<code>request</code> 事件，监听客户端的请求</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块 </span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 web 服务器实例 </span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`server is running.... at 3000`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 为服务器实例绑定 request 事件，监听客户端的请求 </span></span><br><span class="line"><span class="comment">// 当客户端发送请求到服务器的时候，会触发这个事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里要处理客户端的请求</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello yohuohuohuo&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a><strong>端口号</strong></h3><p>计算机中的<strong>端口号</strong></p>
<ol>
<li>计算机和外部通讯的虚拟通道</li>
<li>范围是:<strong>0—65535</strong></li>
<li>一个端口一次<strong>只能被一个</strong>服务占用:<ol>
<li>比较靠前的端口很多已经被电脑默认的服务占用</li>
<li>一般给4位的没什么被占用</li>
</ol>
</li>
<li>通过端口号来区分计算机提供的不同服务</li>
</ol>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1ce6f05-2f54-4dcb-b3b3-2f9182996cf1/Untitled.png" alt="Untitled"></p>
<h3 id="Q-小结-1"><a href="#Q-小结-1" class="headerlink" title="Q 小结"></a>Q 小结</h3><ul>
<li><code>request</code>事件什么时候触发?<ol>
<li>有人访问服务器会触发</li>
</ol>
</li>
<li>一个端口一次可以被几个服务使用?<ol>
<li>一个</li>
</ol>
</li>
<li>代码中的<code>3000</code>端口是否可以更换?<ol>
<li>可以,有效即可</li>
</ol>
</li>
</ul>
<h2 id="request对象和response对象"><a href="#request对象和response对象" class="headerlink" title="request对象和response对象"></a><strong>request对象和response对象</strong></h2><blockquote>
<p>传送门:request</p>
<p><a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">传送门:response</a></p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a><strong>概念:</strong></h3><ol>
<li>为了让开发者更好的<strong>接收请求</strong>的信息,及<strong>设置返回</strong>的内容</li>
<li><code>request</code>事件中提供了<strong>2个</strong>参数,分别是<ol>
<li><code>request</code></li>
<li><code>response</code></li>
</ol>
</li>
</ol>
<h3 id="request常见属性："><a href="#request常见属性：" class="headerlink" title="request常见属性："></a><strong><strong>request常见属性：</strong></strong></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">headers</span>: 所有的请求头信息</span><br><span class="line">method： 请求的方式(*)</span><br><span class="line">url： 请求的地址(*)</span><br></pre></td></tr></table></figure>

<h3 id="response常见属性和方法"><a href="#response常见属性和方法" class="headerlink" title="response常见属性和方法"></a><strong><strong>response常见属性和方法</strong></strong></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">end</span>(data); 结束请求，并且响应一段内容，相当于res.<span class="title function_">write</span>(data) + res.<span class="title function_">end</span>()</span><br><span class="line">res.<span class="property">statusCode</span>: 响应的的状态码 <span class="number">200</span> <span class="number">404</span> <span class="number">500</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(name, value); 设置响应头信息， 比如content-type</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试:"></a><strong>测试:</strong></h3><ol>
<li>输出<code>request</code>对象中的<code>method</code>和<code>url</code>属性</li>
<li>通过<code>statusCode</code>属性设置不同的状态码</li>
<li>通过<code>setHeader</code>设置响应头</li>
<li>通过<code>end</code>设置不同的内容</li>
<li><strong>注意:</strong><ol>
<li>代码更改之后需要<code>ctrl+c</code>关闭并重新运行</li>
<li><code>favicon.ico</code>的请求是浏览器自己发送的</li>
<li>返回的内容中如果有<strong>中文会乱码</strong></li>
</ol>
</li>
</ol>
<h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a><strong>解决中文乱码问题</strong></h3><p>当调用 <code>res.end()</code> 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式,下面给出一些<code>content-type</code>的设置方法</p>
<p><strong>注意:</strong></p>
<ul>
<li>部分内容可以省略<code>content-type</code>设置,浏览器可以自行推断</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通文本</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="comment">// html</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如何理解<code>request</code>和<code>response</code>对象?<ol>
<li><code>request</code>:<ol>
<li>请求,http模块,客户端请求的信息 保存到了 request中方便调用</li>
<li><code>url</code></li>
<li><code>method</code></li>
</ol>
</li>
<li><code>response</code><ol>
<li>响应,http模块为了让开发者,可以便捷的设置状态码,响应头,内容,提供了这么一个对象</li>
<li><code>statusCode</code>属性</li>
<li><code>setHeader(key,value)</code></li>
<li><code>response.setHeader(&#39;Content-Type&#39;, &#39;text/plain; charset=utf-8&#39;)</code></li>
<li><code>end(&#39;内容&#39;)</code></li>
</ol>
</li>
</ol>
</li>
<li>回调函数中<code>request</code>和<code>response</code>的名字是否可以修改?<ol>
<li>可以—&gt;形参</li>
</ol>
</li>
</ul>
<h2 id="根据url响应不同的html内容"><a href="#根据url响应不同的html内容" class="headerlink" title="根据url响应不同的html内容"></a><strong>根据url响应不同的html内容</strong></h2><blockquote>
<p>接下来咱们结合目前学习的知识来实现一个具体的效果</p>
</blockquote>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求:"></a><strong>需求:</strong></h3><ol>
<li><code>url</code>为<ol>
<li><code>/</code>或者<code>/index.html</code>–&gt;<code>&lt;h1&gt;首页&lt;/h1&gt;</code></li>
<li><code>/about.html</code>–&gt;<code>&lt;h1&gt;about页面&lt;/h1&gt;</code></li>
<li>其他—-&gt;<code>&lt;h1&gt;404 not found&lt;/h1&gt;</code></li>
</ol>
</li>
</ol>
<h2 id="练习-时钟案例"><a href="#练习-时钟案例" class="headerlink" title="练习-时钟案例"></a>练习-时钟案例</h2><blockquote>
<p>接下来结合目前所学的知识来完成一个demo</p>
</blockquote>
<h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求:"></a><strong>需求:</strong></h3><p>浏览器输入<strong>对应的url地址</strong>,<strong>读取并返回</strong>对应的文件</p>
<ol>
<li><code>/</code>或者<code>/index.html</code>–&gt;返回<code>/clock/index.html</code></li>
<li><code>/clock.css</code>–&gt;返回<code>/clock/clock.css</code></li>
<li><code>/clock.js</code>–&gt;返回<code>/clock/clock.js</code></li>
<li>其他—-&gt;<code>&lt;h1&gt;404 not found&lt;/h1&gt;</code></li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a><strong>分析:</strong></h3><ol>
<li><strong>绝对路径</strong>读取文件需要导入?<ol>
<li><code>path.join()</code></li>
<li><code>fs.readFileSync</code></li>
</ol>
</li>
<li><strong>返回</strong>读取的文件<ol>
<li><code>end</code>方法响应内容</li>
</ol>
</li>
<li><strong>不需要</strong>设置<code>utf-8</code>的编码格式（读取文件不需要）</li>
<li><strong>不需要</strong>设置<code>content-type</code></li>
</ol>
<h1 id="实现静态WEB服务器"><a href="#实现静态WEB服务器" class="headerlink" title="实现静态WEB服务器"></a><strong>实现静态WEB服务器</strong></h1><blockquote>
<p>基于上一节的代码,调整为静态web服务器</p>
<ul>
<li>运行之后</li>
<li>同一局域网中的用户输入<ul>
<li><code>http://ip:端口/xxx.html</code></li>
<li><code>http://ip:端口/xxx.png</code></li>
</ul>
</li>
<li>即可访问服务器<code>www</code>目录中对应的文件</li>
</ul>
</blockquote>
<blockquote>
<p>首先完成响应首页的逻辑</p>
</blockquote>
<h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求:"></a><strong>需求:</strong></h3><ol>
<li>浏览器中输入<code>/</code>或者<code>/index.html</code></li>
<li>读取并返回<code>www</code>目录中的<code>index.html</code></li>
</ol>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a><strong>分析:</strong></h3><ol>
<li><strong>准备工作</strong>:<ol>
<li>创建<code>www</code>目录并整合上一节的时钟界面</li>
</ol>
</li>
<li><strong>绝对路径</strong>读取文件,需要导入哪些模块?<ol>
<li>fs</li>
<li>path</li>
</ol>
</li>
<li><strong>返回读取的内容</strong><ol>
<li><code>end</code>方法响应内容</li>
</ol>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 web 服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8848</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;my server start work&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 为服务器实例绑定 request 事件，监听客户端的请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断地址 / 和 /index.html ---&gt;/index.html</span></span><br><span class="line">  <span class="keyword">let</span> url = request.<span class="property">url</span></span><br><span class="line">  <span class="comment">// 1./ /index.html 读取并返回 index.html</span></span><br><span class="line">  <span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span> || url === <span class="string">&#x27;/index.html&#x27;</span>) &#123;</span><br><span class="line">    url = <span class="string">&#x27;/index.html&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取并返回</span></span><br><span class="line">  <span class="comment">// 绝对路径 读取内容 响应给浏览器</span></span><br><span class="line">  <span class="keyword">const</span> fullPath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./www&#x27;</span>, url)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = fs.<span class="title function_">readFileSync</span>(fullPath)</span><br><span class="line">    response.<span class="title function_">end</span>(res)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于上一小节的逻辑,完成后续的代码</p>
</blockquote>
<h3 id="需求-3"><a href="#需求-3" class="headerlink" title="需求:"></a><strong>需求:</strong></h3><ol>
<li>请求其他的资源,读取<code>www</code>目录中对应的文件并返回</li>
<li>读取失败响应<code>404</code>-&gt;<code>not found</code></li>
</ol>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤:"></a><strong>步骤:</strong></h3><ol>
<li><strong>生成</strong>读取的<strong>文件路径</strong><ol>
<li>基于<code>url</code>属性,生成绝对路径</li>
</ol>
</li>
<li><strong>返回</strong>读取的内容<ol>
<li><code>end</code>方法</li>
</ol>
</li>
</ol>
<h2 id="end"><a href="#end" class="headerlink" title="end~~~~~~~~~~~~"></a>end~~~~~~~~~~~~</h2><hr>
<p><a href="https://www.electronjs.org/zh/docs/latest">简介 | Electron</a></p>
<ul>
<li><a href="https://github.com/remy/nodemon">https://github.com/remy/nodemon</a></li>
<li><a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g nodemon</span><br><span class="line"></span><br><span class="line">nodemon [your node app]</span><br></pre></td></tr></table></figure>

<p>node本地启动服务，同一个局域网下，要关闭电脑的防火墙才能访问。</p>
<p>自己手机开热点，ipconfig ； 关掉电脑防火墙； 可以访问</p>
<p><a href="https://blog.csdn.net/z17864151193/article/details/123897689">vite启动后提示”Network: use <code>--host</code> to expose”，且无法通过网络IP访问服务_南桥几许的博客-CSDN博客_vite 局域网访问</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ip = req.<span class="property">socket</span>.<span class="property">localAddress</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ip)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://$&#123;hostname&#125;:$&#123;port&#125;/</span></span><br><span class="line">server.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server running at <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">url</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">method</span>)</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> fullPath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> fileHTML = fs.<span class="title function_">readFileSync</span>(fullPath)</span><br><span class="line">  res.<span class="title function_">end</span>(fileHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="nodemon的安装"><a href="#nodemon的安装" class="headerlink" title="nodemon的安装"></a>nodemon的安装</h3><p>当我们修改了后台node服务器的代码之后，都需要重启node服务器。我们可以<strong>使用nodemon来自动重启服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装nodemon</span></span><br><span class="line"><span class="comment"># npm </span></span><br><span class="line">npm install -g nodemon </span><br><span class="line"><span class="comment"># or using yarn: </span></span><br><span class="line">yarn global add nodemon</span><br></pre></td></tr></table></figure>

<h3 id="Node-js-Web框架"><a href="#Node-js-Web框架" class="headerlink" title="Node.js-Web框架"></a>Node.js-Web框架</h3><ol>
<li><a href="https://www.expressjs.com.cn/">Express</a></li>
<li><a href="https://www.koajs.com.cn/">koa</a></li>
</ol>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c3cca3d-315c-4665-9a81-0023351eaaf5/Untitled.png" alt="Untitled"></p>
<h3 id="Mock数据"><a href="#Mock数据" class="headerlink" title="Mock数据"></a>Mock数据</h3>]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>this指向练习</title>
    <url>/2022/11/17/this%E6%8C%87%E5%90%91%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullname = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   <span class="attr">fullname</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">   <span class="attr">prop</span>: &#123;</span><br><span class="line">      <span class="attr">fullname</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">      <span class="attr">getFullname</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">fullname</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">prop</span>.<span class="title function_">getFullname</span>()); <span class="comment">//c</span></span><br><span class="line"><span class="keyword">var</span> test = obj.<span class="property">prop</span>.<span class="property">getFullname</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">test</span>());  <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">        <span class="attr">bar</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">baz</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">         <span class="attr">baz</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (f=foo.<span class="property">bar</span>)()); </span><br><span class="line"><span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//012</span></span><br></pre></td></tr></table></figure>

<h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reduce</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">a</span> -<span class="number">2</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">add</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">reduce</span>()); </span><br><span class="line"><span class="comment">//12</span></span><br><span class="line"><span class="comment">//NAN</span></span><br></pre></td></tr></table></figure>

<h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;yideng&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi.<span class="title function_">call</span>(person, <span class="number">21</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi.<span class="title function_">bind</span>(person, <span class="number">21</span>)); </span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    a[i] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]()</span><br><span class="line"><span class="comment">//10   每一个都是10 a[10,10,...,10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    a[i] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]()</span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">let</span> 不会变量提升，形成块级作用域(i等于<span class="number">0</span>到<span class="number">9</span>)</span><br><span class="line"><span class="number">2.</span>会在块级作用域中，找对应的i，输入的是<span class="number">6</span>，找的也是i=<span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">typeof</span> <span class="literal">null</span>, <span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>]  </span><br><span class="line"><span class="comment">//[object,false]</span></span><br><span class="line"><span class="comment">// null基本</span></span><br><span class="line"><span class="comment">// Object 引用</span></span><br></pre></td></tr></table></figure>

<h4 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showCase</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case A&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case B&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">undefined</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;undefined&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Do not know!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showCase</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;A&#x27;</span>));<span class="comment">//new 创建对象</span></span><br><span class="line"><span class="comment">//switch  严格比较 ===</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;str&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str1)  <span class="comment">//Do not know!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str2)  <span class="comment">//undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>vue基础指令</title>
    <url>/2022/11/23/vue%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式  "></a>插值表达式  </h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; obj.age &gt;= 18 ? &#x27;成年&#x27; : &#x27;未成年&#x27; &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 需要为每一个组件起上名字 =&gt; 命名要求: 必须以多个单词的驼峰式命名</span><br><span class="line">  name: &#x27;DemoIndex1&#x27;,</span><br><span class="line">  // vue 组件中的数据，必须写在data方法的返回值对象中作为属性</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;helloWorld&#x27;,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: &#x27;张三&#x27;,</span><br><span class="line">        age: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-bind-动态的绑定一个或多个属性"><a href="#v-bind-动态的绑定一个或多个属性" class="headerlink" title="v-bind  动态的绑定一个或多个属性"></a>v-bind  动态的绑定一个或多个属性</h3><p>语法： v-bind:属性名=”vue中定义的变量/表达式”</p>
<p>简写: 将v-bind: 转化为 : =&gt; :属性名=”vue中定义的变量/表达式”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- </span><br><span class="line">      动态属性</span><br><span class="line">      语法： v-bind:属性名=&quot;vue中定义的变量/表达式&quot;</span><br><span class="line">      简化的语法： 将v-bind: 转化为 : =&gt; :属性名=&quot;vue中定义的变量/表达式&quot;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a v-bind:href=&quot;hrefUrl&quot;&gt;www.baidu.com&lt;/a&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;!-- 关于v-bind动态属性作用于图片时尤其需要注意</span><br><span class="line">      v-bind 会直接讲资源路径认定为字符串</span><br><span class="line">      如何解决呢？ 直接在v-bind动态属性后面传递实际的资源</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;img src=&quot;../assets/123.png&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;img v-bind:src=&quot;imgUrl1&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;img :src=&quot;imgUrl2&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;img :src=&quot;imgUrl3&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 通过import引入资源文件，在data中进行定义，最后再动态属性中使用</span><br><span class="line">import img from &#x27;../assets/123.png&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DemoIndex2&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      hrefUrl: &#x27;http://www.baidu.com&#x27;,</span><br><span class="line">      imgUrl1: &#x27;../assets/123.png&#x27;,</span><br><span class="line">      imgUrl2: img,</span><br><span class="line">      // require 引入资源文件， 直接在动态属性中使用</span><br><span class="line">      // 优势： require引入资源的方式是按需的，这样一来，页面初始更新效率会更高</span><br><span class="line">      imgUrl3: require(&#x27;../assets/123.png&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-on事件绑定"><a href="#v-on事件绑定" class="headerlink" title="v-on事件绑定"></a>v-on事件绑定</h3><p>vue项目的一个本质理念: 数据驱动视图 （在做任何需求时，首选通过数据来修改）</p>
<p>在vue的标签中，如果想要访问data中的数据，或者调用methods中的方法，需要在前面加上this</p>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>简写: v-on: =&gt; @   @事件名=”methods中定义的方法”</p>
<ol>
<li>  v-on:事件名=”简单的函数执行体” =&gt; 只有一行代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;count++&quot;&gt;点击加一&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>v-on:事件名=”methods中定义的方法”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;addCount1&quot;&gt;点击加一&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            count:0,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // vue组件中的方法要写在methods中</span><br><span class="line">    methods:&#123;</span><br><span class="line">        //点击加一</span><br><span class="line">        addCount1()&#123;</span><br><span class="line">            this.count += 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>v-on:事件名=”methods中定义的方法(实际参数)”</p>
<p>   总结经验： 如果方法不需要传参，那么不要去写小括号</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;addCount(5)&quot;&gt;点击加5&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            count:0,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // vue组件中的方法要写在methods中</span><br><span class="line">    methods:&#123;</span><br><span class="line">        //点击加五</span><br><span class="line">        addCount1(num)&#123;</span><br><span class="line">            this.count += num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="有无参数传递"><a href="#有无参数传递" class="headerlink" title="有无参数传递"></a>有无参数传递</h5><ol>
<li>无参数状态 =&gt; @click=”goUrl” 在v-on指令后绑定方法时不加小括号的形式</li>
</ol>
<p>​           在定义方法时默认的事件对象在第一个形参上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a @click=&quot;goUrl&quot; href=&quot;http://www.baidu.com&quot;&gt;百度（无参）&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    // vue组件中的方法要写在methods中</span><br><span class="line">    methods:&#123;</span><br><span class="line">        goUrl(event)&#123;</span><br><span class="line">            //阻止默认事件</span><br><span class="line">            event.preventDefault()</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>有参数状态(绑定方法时后面有括号的形式) =&gt; @click=”goUrl2()”</li>
</ol>
<p>​                        在定义方法时主动传递事件对象 @click=”goUrl2($event)”</p>
<p>​                        使用时，对应实参位置设置新参即可使用</p>
<p>​     原因: 只要在使用方法时打上小括号，就会覆盖原本vue默认设置在第一个形参上的事件对象参数 ,所以要手动添加$event</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a @click=&quot;goUr2(1,$event)&quot; href=&quot;http://www.baidu.com&quot;&gt;百度（有参）&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    // vue组件中的方法要写在methods中</span><br><span class="line">    methods:&#123;</span><br><span class="line">        goUr2(num,event)&#123;</span><br><span class="line">            event.preventDefault()</span><br><span class="line">            console.log(num,event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>语法：@事件名.修饰符=”方法”</p>
<p>​      @click.prevent=”preventFn” =&gt; 阻止默认事件 =&gt; 最为常用的修饰符</p>
<p>​      @click.stop=”stopFn” =&gt; 阻止事件冒泡 =&gt; 一般</p>
<p>​      @click.once=”onceFn” =&gt; 绑定的事件只有一次有效 =&gt; 罕见</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;fatherFn&quot;&gt;</span><br><span class="line">        &lt;p @click.stop=&quot;stopFn&quot;&gt;阻止事件冒泡&lt;/p&gt;</span><br><span class="line">        //可以多个修饰符一起使用</span><br><span class="line">        &lt;a @click.prevent.stop=&quot;preventFn&quot; href=&quot;http://www.baidu.com&quot;&gt; 阻         止默认事件&lt;/a&gt;</span><br><span class="line">        &lt;!-- 和once一起的修饰符，也只执行一次 --&gt;</span><br><span class="line">        &lt;p @click.once=&quot;onceFn&quot;&gt;只执行一次&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    // vue组件中的方法要写在methods中</span><br><span class="line">    methods:&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="键盘事件的修饰符"><a href="#键盘事件的修饰符" class="headerlink" title="键盘事件的修饰符"></a>键盘事件的修饰符</h3><p>@keyup.enter =&gt; 监听回车按键，只有按下回车时才会触发绑定的方法</p>
<p>@keyup.esc =&gt;  监听返回按键，只有按下返回时才会触发绑定的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 按下enter时才会触发绑定的方法</span><br><span class="line">&lt;input type=&quot;text&quot; @keyup.enter=&quot;keyFn1&quot;&gt;</span><br><span class="line">// 按下esc时才会触发绑定的方法</span><br><span class="line">&lt;input type=&quot;text&quot; @keyup.esc=&quot;keyFn2&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model 双向绑定"></a>v-model 双向绑定</h3><p>语法: v-model=”vue数据变量”</p>
<p>v-model 这个指令可以实现表单控件中数据与视图的双向绑定</p>
<ol>
<li><p>数据改变 =&gt; 视图自动同步</p>
<ol start="2">
<li>视图改变 =&gt; 数据自动同步</li>
</ol>
</li>
</ol>
<h5 id="1-文本框"><a href="#1-文本框" class="headerlink" title="1.文本框"></a>1.文本框</h5><p>input 文本框 ，将value属性替换成v-model</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-下拉选项框"><a href="#2-下拉选项框" class="headerlink" title="2.下拉选项框"></a>2.下拉选项框</h5><p>下拉选项框 select 将name属性替换成 v-model </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select v-model=&quot;city&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-单选框"><a href="#3-单选框" class="headerlink" title="3.单选框"></a>3.单选框</h5><p>单选框 将name属性 替换成v-model</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;sex&quot; value=&quot;男&quot;/&gt; 男</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;sex&quot; value=&quot;女&quot;/&gt; 女</span><br></pre></td></tr></table></figure>

<h5 id="4-复选框"><a href="#4-复选框" class="headerlink" title="4.复选框"></a>4.复选框</h5><p>4.1    将name 属性替换成 v-model 中绑定一个数组，选中项就是数组中的每个一元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;唱&quot;/&gt; 唱</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;跳&quot;/&gt; 跳</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;rap&quot;/&gt; rap</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">         return &#123;</span><br><span class="line">            hobby:[]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>4.2   将name 属性替换成 v-model 中绑定一个非数组，当切换选择状态时会以布尔值的形式来做状态切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;唱&quot;/&gt; 唱</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;跳&quot;/&gt; 跳</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;rap&quot;/&gt; rap</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">         return &#123;</span><br><span class="line">            hobby1:&#x27;&#x27;,</span><br><span class="line">            hobby2:false,</span><br><span class="line">            hobby3:0,</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 都会隐式转换成布尔值</span><br></pre></td></tr></table></figure>

<h3 id="v-model-的修饰符"><a href="#v-model-的修饰符" class="headerlink" title="v-model 的修饰符"></a>v-model 的修饰符</h3><ol>
<li>v-model.number 将输入框中的值以 parseFloat 的形式转化为数字类型 (常用)</li>
</ol>
<p>​    会自动清除后续非数字部分  parseFloat(1.22.3)  ===&gt; 1.22</p>
<p>​    如果第一个字符就不是数字时，.number修饰符就失效了</p>
<ol start="2">
<li><p>v-model.trim  去除收尾空格字符 (常用)</p>
<ol start="3">
<li>v-model.lazy  将input(输入)时触发的实时更新数据操作转移到change(失焦、回车)时触发</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;转化数字&lt;/span&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model.number=&quot;newNumber&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;取消前后空格&lt;/span&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model.trim=&quot;newTrim&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;懒更新&lt;/span&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model.lazy=&quot;newLazy&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-text与v-html"><a href="#v-text与v-html" class="headerlink" title="v-text与v-html"></a>v-text与v-html</h3><p>v-text =&gt; 代替了webapi中的 innerText</p>
<p>v-html =&gt; 代替了webapi中的 innerHTML</p>
<p>观察发现 v-text 使用时不允许当前标签内有任何子元素  </p>
<p>及<p v-text="text">123</p>  中间不能有123</p>
<p>原因: 本来当前元素中的内容就会被v-text中的内容覆盖，所以当前标签中的子元素显得毫无意义甚至影响页面的渲染效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt;   // &lt;span&gt;这是一个字符串&lt;/span&gt;</span><br><span class="line">&lt;p v-html=&quot;text&quot;&gt;&lt;/p&gt;   // 这是一个字符串</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;DemoInfo07&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            text:&#x27;&lt;span&gt;这是一个字符串&lt;/span&gt;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>用来隐藏标签的</p>
<p>语法：v-show=”变量”</p>
<p>原理: 给当前标签设置一个display: none; 来进行隐藏操作，原来的这个标签元素还存在于dom数中</p>
<p>通过变量的boolean值隐式转化，来判断是true或者是false，为true时显示，为false时隐藏</p>
<p>隐式转化为false的情况: 0 / ‘’ / null / undefined / NaN </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-show=&quot;flag1&quot;&gt;v-show&lt;/div&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;DemoInfo&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      flag1: true, // 显示</span><br><span class="line">      flag1: false,// 隐藏</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p> *** 选择v-show和v-if的直接条件: 如果当前元素及内部子元素全是静态数据，那么使用v-show，除此以外全用v-if***</p>
<p>语法：v-if=”变量”</p>
<p>原理: 直接将需要隐藏的元素从dom树中删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;flag1&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;DemoInfo&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      flag1: true,</span><br><span class="line">      msg: &quot;动态数据&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以和 v-else-if 和 v-else进行连用，它的判断逻辑与 js中 if else 完全相同</p>
<p>当使用v-if/v-else-if/v-else 时，他们之间必须是连续的兄弟标签,中间不能有其他标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div v-if=&quot;flag2 === &#x27;&#x27;&quot;&gt;显示0&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;flag2 === 1&quot;&gt;显示1&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;flag2 === 2&quot;&gt;显示2&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;显示其他&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="v-for-数据循环指令"><a href="#v-for-数据循环指令" class="headerlink" title="v-for 数据循环指令"></a>v-for 数据循环指令</h3><p> 与forEach的使用方式进行联合记忆，它每次循环得到的数据和索引的用法与forEach完全一样</p>
<ol>
<li><p>v-for=”(value, index) in 目标数据结构”</p>
</li>
<li><p>v-for=”value in 目标数据结构”</p>
</li>
</ol>
<p>在v-for循环体中，必须为每一个循环标签加上一个key属性来表示当前标签的唯一性（不加直接报错）</p>
<h5 id="1-循环数组"><a href="#1-循环数组" class="headerlink" title="1.循环数组"></a>1.循环数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div v-for=&quot;(value,index) in arr&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;DemoInfo10&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            arr:[&quot;a&quot;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//   a-----0</span><br><span class="line">//   b-----1</span><br><span class="line">//   c-----2</span><br></pre></td></tr></table></figure>

<h5 id="2-循环复杂数组-（数组对象）"><a href="#2-循环复杂数组-（数组对象）" class="headerlink" title="2.循环复杂数组  （数组对象）"></a>2.循环复杂数组  （数组对象）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;value in arr1&quot; :key=&quot;value.index&quot;&gt;</span><br><span class="line">    &#123;&#123; value.name &#125;&#125; -----&#123;&#123;value.age&#125;&#125; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;DemoInfo10&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            arr1:[</span><br><span class="line">                &#123;name:&#x27;ff&#x27;,age:&#x27;30&#x27;&#125;,</span><br><span class="line">                &#123;name:&#x27;ss&#x27;,age:&#x27;60&#x27;&#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//   ff-----30</span><br><span class="line">//   ss-----60</span><br></pre></td></tr></table></figure>

<h5 id="3-循环对象"><a href="#3-循环对象" class="headerlink" title="3.循环对象"></a>3.循环对象</h5><p>参数一：属性值</p>
<p>参数二：属性名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value,key) in obj&quot; :key=&quot;key&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125; ----- &#123;&#123; key &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;DemoInfo10&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            obj:&#123;</span><br><span class="line">                name:&quot;mmm&quot;,</span><br><span class="line">                age:&quot;30&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// mmm------name</span><br><span class="line">// 30 ----- age</span><br></pre></td></tr></table></figure>

<h5 id="4-循环数字"><a href="#4-循环数字" class="headerlink" title="4.循环数字"></a>4.循环数字</h5><p>参数一：从1开始计数到最后的数字</p>
<p>参数二：下标索引0开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value,index) in 5&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 1 ----- 0</span><br><span class="line">// 2 ----- 1</span><br><span class="line">// 3 ----- 2</span><br><span class="line">// 4 ----- 3</span><br><span class="line">// 5 ----- 4</span><br></pre></td></tr></table></figure>

<h5 id="5-循环字符串"><a href="#5-循环字符串" class="headerlink" title="5.循环字符串"></a>5.循环字符串</h5><p>参数一：字符串的每个字符</p>
<p>参数二：下标索引0开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value,index) in &#x27;cvb&#x27;&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// c ----- 0</span><br><span class="line">// v ----- 1</span><br><span class="line">// b ----- 2</span><br></pre></td></tr></table></figure>

<h3 id="v-for与v-if不能一起使用"><a href="#v-for与v-if不能一起使用" class="headerlink" title="v-for与v-if不能一起使用"></a>v-for与v-if不能一起使用</h3><p>v-for 会比 v-if 有更高的优先级，v-for会先循环出数据，然后v-if判断哪些不符合的数据进行删除。</p>
<p>一增一删，浪费性能</p>
<p>解决方案： 直接把v-if中的逻辑判断放到filter的函数执行体中即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div v-for=&quot;(value,index) in arr3.filter(value =&gt; value &gt;= 3)&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">            &#123;&#123; value &#125;&#125; ----- &#123;&#123; index &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;DemoInfo10&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">        //渲染大于等于3的数据</span><br><span class="line">            arr3:[8,6,5,59,1,3]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>vue文件的初始使用</title>
    <url>/2022/11/22/vue%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="根组件-App-vue"><a href="#根组件-App-vue" class="headerlink" title="根组件  App.vue"></a>根组件  App.vue</h3><p>所有vue组件，都要在根组件中进行<strong>引入、注册、使用</strong>，才可以显示在页面上</p>
<p>只有根组件才与main.js进行交互</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 标签模板 =&gt; 对应记忆对照html文件中的&lt;html&gt;标签结构 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 3.使用：通过注册的标签，来使用组件 --&gt;</span><br><span class="line">    &lt;Demo&gt;&lt;/Demo&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js相关的代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 在js中 有一个 export default &#123;&#125; 结构， 在这个结构中需要遵循vue的代码规则</span><br><span class="line">// 1. 引入组件</span><br><span class="line">import Demo from &#x27;./components/01-插值表达式.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 命名（只有根组件才能以app命名）</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  //2.注册组件</span><br><span class="line">  components: &#123;</span><br><span class="line">    Demo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 相当于css --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  /* 当前组件样式表 - 期望每个组件中的style 标签只能影响当前组件中的标签内容 */</span><br><span class="line">  /* 只需要在style 标签中添加一个属性 - scoped 就可以让样式只作用于当前组件的标签 */</span><br><span class="line">  /* 原理: scoped 属性，会为每一个样式表自动添加当前组件中所被设置的自定义属性（data-v-hash随机数），形参一个复合选择器，而能够被选中的标签均存在于当前组件中，所以可以被区分开 */</span><br><span class="line">  /* 规律/要求: 只要组件需要设置style样式，就在style标签中添加 scoped 属性 */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="mian-js-入口文件"><a href="#mian-js-入口文件" class="headerlink" title="mian.js  入口文件"></a>mian.js  入口文件</h3><p>入口文件最关键的特点：想某个页面和文件在项目中生效，一定会直接或者间接的与入口文件产生联系</p>
<p>将根组件是数据，挂载到index.html上，然后就可以出现载页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入vue依赖 =&gt; 如果是第三方依赖，路径不会写成相对和绝对路径</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入根组件</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">// vue的控制台打印提示</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App), // 渲染函数，告诉vue要渲染那个组件</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)  //挂载到那里  =&gt; id为app的盒子中</span><br></pre></td></tr></table></figure>

<h3 id="其他功能组件"><a href="#其他功能组件" class="headerlink" title="其他功能组件"></a>其他功能组件</h3><p>一定要在根组件中，<strong>引入、注册、使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">//有且只有一个标签  (一般是div)</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;!-- 通过 &#123;&#123;  &#125;&#125; 来设置插值表达式 --&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;obj.age &gt;= 18 ? &quot;成年&quot; : &quot;未成年&quot; &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">   // 需要为每一个组件起上名字 =&gt; 命名要求: 必须以多个单词的驼峰式命名</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    // vue 组件中的数据，必须写在data方法的返回值对象中作为属性</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg:&#x27;hello&#x27;,</span><br><span class="line">            obj:&#123;</span><br><span class="line">                name:&quot;dfs&quot;,</span><br><span class="line">                age:20,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;style&gt;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>vue的数据更新机制 (v-for)</title>
    <url>/2022/11/25/vue%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%EF%BC%88v-for%EF%BC%89/</url>
    <content><![CDATA[<h3 id="改变数组的方法"><a href="#改变数组的方法" class="headerlink" title="改变数组的方法"></a>改变数组的方法</h3><h5 id="能够改变原数组的数组方法"><a href="#能够改变原数组的数组方法" class="headerlink" title="能够改变原数组的数组方法"></a>能够改变原数组的数组方法</h5><p>​    push 后增</p>
<p>​    unshift 前增</p>
<p>​    pop 后删</p>
<p>​    shift 前删</p>
<p>​    splice 参数2为参数 参数3为新增</p>
<p>​    reverse 数组颠倒</p>
<p>​    sort 冒泡排序</p>
<h5 id="不可以修改原数组的方法"><a href="#不可以修改原数组的方法" class="headerlink" title="不可以修改原数组的方法"></a>不可以修改原数组的方法</h5><p>​    slice 截取数组</p>
<p>​    filter 过滤数组</p>
<p>​    reduce 累加</p>
<p>​    map 返回修改后的新数组</p>
<p>​    concat 数组拼接</p>
<h3 id="v-for的更新检测机制"><a href="#v-for的更新检测机制" class="headerlink" title="v-for的更新检测机制"></a>v-for的更新检测机制</h3><ol>
<li><p>如果希望v-for中循环的内容发生变化，必须改变原数组。如果某些方法无法改变原数组时，进行重新赋值的操作</p>
</li>
<li><p>修改数据时有时会遇到非标准化的修改方式，此时可以用到this.$set来强制更新，但是尽量去寻找标准化的修改方式与之代替</p>
</li>
</ol>
<p>​    修改数组元素的标准化方式： splice(需要修改的元素目标索引, 1, 更新的值)</p>
<p>this.$set(更新的目标结构, 更新的位置, 更新的数据)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;changeFirstBtn&quot;&gt;点击修改第一个元素&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DemoIndex01&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      arr1: [5, 3, 6, 8, 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    // 修改第一个元素</span><br><span class="line">    changeFirstBtn () &#123;</span><br><span class="line">      // 这种直接通过索引改变数组某个元素的方式不是标准修改形式</span><br><span class="line">      // 通过length进行数组元素的增加和删除的方式也不是标准修改形式</span><br><span class="line">      this.arr1[0] = 1000</span><br><span class="line">      // 发现通过索引到的方式无法让页面监听到数组元素的改变</span><br><span class="line">      // 通过 vue 提供的内置方法来强制刷新 =&gt; this.$set</span><br><span class="line">      // this.$set(更新的目标结构, 更新的位置, 更新的数据)</span><br><span class="line">      // 如果某个修改数据的方法需要用到this.$set才可以实现数据监听时，那么这个方法一定不是一个标准化的规范修改过程，一定有与之替换的标准化解决方案，所以去用标准方案吧</span><br><span class="line">      this.$set(this.arr1, 0, 1000)</span><br><span class="line"></span><br><span class="line">      // splice 是修改数组中某个元素的标准化解决方案</span><br><span class="line">      // this.arr1.splice(0, 1, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vue数据更新机制（v-for立即更新）"><a href="#vue数据更新机制（v-for立即更新）" class="headerlink" title="vue数据更新机制（v-for立即更新）"></a>vue数据更新机制（v-for立即更新）</h3><p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。</p>
<p>传统的就将所有Dom节点删除，将新的数据，从新渲染到页面上（太耗费性能）</p>
<p>v-for更新，简单来说就是不删除原来的dom元素，而是尽量去修改各循环元素内部的值</p>
<h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>概念：.vue文件中的template里写的标签, 都是模板, 都要被vue处理成虚拟DOM对象, 才会渲染显示到真实DOM页面上</p>
<p><strong>虚拟DOM优势：</strong>虚拟DOM保存在内存中, 只记录dom关键信息, 配合diff算法提高DOM更新的性能</p>
<p>内存中生成一样的虚拟DOM结构 (==本质是个JS对象==)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;box&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;my_p&quot;&gt;123&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">对应的虚拟DOM结构</span><br><span class="line">const dom = &#123;</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">    attributes: [&#123;id: &#x27;box&#x27;&#125;],</span><br><span class="line">    children: &#123;</span><br><span class="line">        type: &#x27;p&#x27;,</span><br><span class="line">        attributes: [&#123;class: &#x27;my_p&#x27;&#125;],</span><br><span class="line">        text: &#x27;123&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue数据更新</p>
<ul>
<li><p>生成新的虚拟DOM结构</p>
</li>
<li><p>和旧的虚拟DOM结构对比</p>
</li>
<li><p>利用diff算法, 找不不同, 只更新变化的部分(重绘/回流)到页面</p>
<h5 id="diff算法—同级比较"><a href="#diff算法—同级比较" class="headerlink" title="diff算法—同级比较"></a>diff算法—同级比较</h5><p>就是，生成新虚拟dom存在内存里, 和旧的虚拟dom比较，如果不一致，就将不一致的地方进行修改</p>
<ol>
<li>只进行同级比较</li>
<li>如果根元素不同，直接删除重建</li>
<li>根元素没变, 属性改变 =&gt;  元素复用, 只更新属性</li>
</ol>
</li>
</ul>
<p>第一种更新方法：  :key=’index’</p>
<ol>
<li><p>v-for先循环产生新的DOM结构, key是连续的, 和数据对应</p>
</li>
<li><p>然后比较新旧DOM结构, 找到区别, 更新到页面上</p>
<p>最后补一个新节点, <strong>然后从新结点开始往后, 都要更新内容</strong></p>
</li>
</ol>
<p>第二种更新方法：  :key=’id’</p>
<ol>
<li><p>v-for先循环产生新的DOM结构, key是连续的, 和数据对应</p>
</li>
<li><p>然后比较新旧DOM结构, 找到区别, 更新到页面上</p>
<p>最后补一个新节点, <strong>只插入新节点，不会更新后面的内容</strong></p>
</li>
</ol>
<h5 id="key的值只能是唯一不重复的-字符串或数值"><a href="#key的值只能是唯一不重复的-字符串或数值" class="headerlink" title="key的值只能是唯一不重复的, 字符串或数值"></a>key的值只能是唯一不重复的, 字符串或数值</h5><h5 id="vue项目渲染页面元素的原理"><a href="#vue项目渲染页面元素的原理" class="headerlink" title="vue项目渲染页面元素的原理"></a>vue项目渲染页面元素的原理</h5><p> =&gt; 只需要记住，v-for循环时key的用法。</p>
<p> =&gt; 在遍历数组时，如果每个元素中都有唯一的id(唯一性), key就用id来表示。如果没有这个唯一值，就使用index索引。</p>
<p> =&gt; 有id用id，没id用索引；id报错时，用索引。</p>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>动态class和动态style,过滤器</title>
    <url>/2022/11/25/%E5%8A%A8%E6%80%81class%E5%92%8C%E5%8A%A8%E6%80%81style%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h3 id="动态class和动态style"><a href="#动态class和动态style" class="headerlink" title="动态class和动态style"></a>动态class和动态style</h3><p>动态class的语法</p>
<ol>
<li>:class=”{ 类名: 可以隐式转化为boolean值的表达式 }”</li>
</ol>
<p>​     切换类名的开关(有效和失效）</p>
<ol start="2">
<li>:class=”[ 携带类名字符串的变量 ]”</li>
</ol>
<p>​     切换不同的类名（不同类名的样式内容可以不同）</p>
<p> 使用场景：</p>
<p>​    1. 如果确定了某一个样式，且只需要这个样式的展示或隐藏时，使用 大括号 常用</p>
<p>​    2. 如果需要切换多种样式，且需要改变类名时，       使用 中括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p :class=&quot;&#123; &#x27;red-style&#x27;: classType &#125;&quot;&gt;:class=&quot;&#123; 类名: 可以隐式转化为boolean值的表达式 &#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;p :class=&quot;[ className ]&quot;&gt;:class=&quot;[ 携带类名字符串的变量 ]&quot;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DemoIndex03&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      classType: true,</span><br><span class="line">      className: &#x27;red-style&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.red-style &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.green-style &#123;</span><br><span class="line">  color: green;</span><br><span class="line">  font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>动态style的语法</p>
<pre><code>     1. :style=&quot;&#123; css属性: 携带描述该css属性的变量 &#125;&quot;
        点:  普通静态样式 style=&quot;color: red; font-size: 12px;&quot;
        动态样式    style=&quot;&#123; color: ??, fontSize: ?? &#125;&quot;
        设置动态样式表的css属性时，如果原本在css中是以多个单词短横线链接的属性名时(如: font-size), 在动态属性中，必须以驼峰式命名(fontSize)
     2. :style=&quot;[ 带有css样式属性键值对的对象变量 ]&quot;
</code></pre>
<p>​      使用场景: </p>
<pre><code>     1. 如果需要切换某个特定css样式的属性值，可以使用过 大伙靠 常用
     2. 如果需要对当前动态样式进行新增或删除样式属性时，可以使用 中括号
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p :style=&quot;&#123; color: colorRed &#125;&quot;&gt; :style=&quot;&#123; css属性: 携带描述该css属性的变量 &#125;&quot; &lt;/p&gt;</span><br><span class="line">&lt;p :style=&quot;[ styleObj ]&quot;&gt; :style=&quot;[ 带有css样式属性键值对的对象变量 ]&quot; &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DemoIndex03&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      colorRed: &#x27;red&#x27;,</span><br><span class="line">      styleObj: &#123;</span><br><span class="line">        color: &#x27;red&#x27;,</span><br><span class="line">        fontSize: &#x27;30px&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.red-style &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.green-style &#123;</span><br><span class="line">  color: green;</span><br><span class="line">  font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="filter过滤器"><a href="#filter过滤器" class="headerlink" title="filter过滤器"></a>filter过滤器</h3><p>语法：</p>
<p>​    全局定义过滤器</p>
<p>​     在 main.js 中，通过 Vue.filter 静态方法</p>
<p>​     Vue.filter(‘自定义过滤器名称 - 驼峰式命名’, (需要过滤的值 - 必填且默认, 使用过滤器时传递进来的参数) =&gt; {</p>
<p>​      …函数执行体</p>
<p>​      return 返回处理后的值</p>
<p>​     })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.js</span><br><span class="line">// 创建将所有字母大写的过滤器</span><br><span class="line">Vue.filter(&#x27;toUp&#x27;, (value) =&gt; &#123;</span><br><span class="line">  // value：需要进行过滤的默认值</span><br><span class="line">  return value.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.vue</span><br><span class="line">&lt;div&gt;全局过滤器：&#123;&#123; str | toUp &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>局部定义过滤器 - 在哪个组件中定义，只能在哪个组件中使用</p>
<p>filters: {</p>
<p>​      ‘自定义过滤器名称 - 驼峰式命名’ (需要过滤的值 - 必填且默认, 使用过滤器时传递进来的参数) {</p>
<p>​       …函数执行体</p>
<p>​       return 返回处理后的值</p>
<p>​      }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用： 在插值表达式中通过 &#123;&#123; 原始数据 | 过滤器名称 &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     &lt;div&gt;原始数据： &#123;&#123; str &#125;&#125; &lt;/div&gt;</span><br><span class="line">     &lt;div&gt;全局过滤器：&#123;&#123; str | toUp &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;局部过滤器: &#123;&#123; str | reverseStr(&#x27;*&#x27;) &#125;&#125; &lt;/div&gt;</span><br><span class="line">     &lt;div&gt;局部过滤器: &#123;&#123; str | reverseStr(&#x27;~&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;叠加过滤器使用： &#123;&#123; str | reverseStr(&#x27;*&#x27;) | toUp &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;简易大写操作： &#123;&#123; str.toUpperCase() &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;简易字符串反转： &#123;&#123; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;简易混合叠加写法： &#123;&#123;str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;).toUpperCase() &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DemoIndex05&#x27;,</span><br><span class="line">  // 反转字符串过滤器</span><br><span class="line">  filters: &#123;</span><br><span class="line">    reverseStr (value, s) &#123;</span><br><span class="line">      return value.split(&#x27;&#x27;).reverse().join(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &#x27;helloworld&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>原型</title>
    <url>/2022/11/20/%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h5 id="构造函数存在的问题"><a href="#构造函数存在的问题" class="headerlink" title="构造函数存在的问题"></a>构造函数存在的问题</h5><p>存在浪费内存的问题</p>
<p>怎么浪费的：每创建一个对象，都会在堆空间中重新开辟一个空间来存储方法····</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Star(name, age) &#123;</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">            this.sing = function () &#123;</span><br><span class="line">                console.log(&#x27;唱歌&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">const kk = new Star(&#x27;坤坤&#x27;, 18)</span><br><span class="line">const jl = new Star(&#x27;杰伦&#x27;, 20)</span><br><span class="line">console.log(kk.sing === jl.sing) // false  表示内存中sing的地址不相等</span><br><span class="line">说明两个对象的方法，分配了不同的内存来存储，浪费了内存</span><br></pre></td></tr></table></figure>

<h5 id="解决内存浪费的问题"><a href="#解决内存浪费的问题" class="headerlink" title="解决内存浪费的问题"></a>解决内存浪费的问题</h5><p>将公共的属性和方法，写在原型对象上，实现共享（因为每个函数上都有一个prototype原型对象）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Star(name, age) &#123;</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">        &#125;</span><br><span class="line">Star.prototype.sing = function () &#123;</span><br><span class="line">            console.log(&#x27;唱歌&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">const kk = new Star(&#x27;坤坤&#x27;, 18)</span><br><span class="line">const jl = new Star(&#x27;杰伦&#x27;, 20)</span><br><span class="line">console.log(kk.sing === jl.sing)  // true</span><br><span class="line"></span><br><span class="line">放在原型上的方法，两个创建的对象都能访问到，还是访问到的同一个</span><br></pre></td></tr></table></figure>

<h5 id="原理的理解"><a href="#原理的理解" class="headerlink" title="原理的理解"></a>原理的理解</h5><p>js原型：原型是一个对象，叫原型对象</p>
<ol>
<li>所有的函数，都有一个prototype属性，属性值是一个普通对象</li>
<li>这个属性是一个指针，指向原型对象</li>
<li>原型上默认有一个叫constructor的属性，指向构造函数的本身</li>
<li>可以在原型对象上添加属性和方法</li>
<li>所有通过构造函数创建的对象，都共享原型上的属性和方法！</li>
</ol>
<h5 id="构造函数和原型方法中this的指向"><a href="#构造函数和原型方法中this的指向" class="headerlink" title="构造函数和原型方法中this的指向"></a>构造函数和原型方法中this的指向</h5><p>   1.构造函数的this指向的是实例对象</p>
<ol start="2">
<li>原型方法中的this指向是还是实例对象</li>
</ol>
<h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>constructors在原型对象上</p>
<p>   1.每个原型（对象）上默认都有一个constructor属性，指向构造函数本身</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Star(name, age) &#123;</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">        &#125;</span><br><span class="line">const ll = new Star(&#x27;磊磊&#x27;, 28)</span><br><span class="line">console.log(Star.prototype.constructor === Star) //true</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>所有对象隐式原型指向构造函数的显式原型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(ll.__proto__ === Star.prototype)    //true</span><br><span class="line">console.log(ll.__proto__.constructor === Star)  //true</span><br></pre></td></tr></table></figure>

<p>一次向原型上添加多个方法的时候，这个时候，原型上的默认属性constructor就会丢失掉。</p>
<p>需要手动给这个对象添加constructor属性，指回这个构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">会覆盖掉原来的原型，需要手动指回创建的构造函数</span><br><span class="line">Star.prototype = &#123;</span><br><span class="line">            constructor:Star, // 指回构造函数</span><br><span class="line">            sing:function()&#123;</span><br><span class="line">                console.log(&#x27;唱歌&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            dance:function()&#123;</span><br><span class="line">                console.log(&#x27;dance&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            rap: function()&#123;</span><br><span class="line">                console.log(&#x27;rap&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="proto-隐式原型"><a href="#proto-隐式原型" class="headerlink" title="__proto__隐式原型"></a>__proto__隐式原型</h5><ol>
<li>所有的的对象，都有一个__proto__属性（隐式原型），属性值也是一个对象（指向的是原型对象）</li>
<li>对象的隐式原型指向构造函数的显示原型</li>
<li><strong>proto</strong> 表示了实例和原型之间的一个关系，相当于就是一个桥梁，实例通过它访问原型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Animal()&#123;</span><br><span class="line">            this.color = &#x27;orange&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">const cat = new Animal()</span><br><span class="line">console.log(cat)</span><br><span class="line">console.log(cat.__proto__ === Animal.prototype)   //true</span><br><span class="line"></span><br><span class="line">&#x27;实例对象.__proto__ === 构造函数.prototype&#x27; ==&gt; 原型</span><br></pre></td></tr></table></figure>

<h5 id="构造函数—实例—原型之间的关系"><a href="#构造函数—实例—原型之间的关系" class="headerlink" title="构造函数—实例—原型之间的关系"></a>构造函数—实例—原型之间的关系</h5><p>四条线： </p>
<p>​    // 1. 构造函数.prototype ===&gt;  原型对象</p>
<p>​    // 2. 原型对象.constructor ===&gt; 构造函数</p>
<p>​    // 3. 实例对象.<strong>proto</strong>  ===&gt; 原型对象</p>
<p>​    // 4. 构造函数 new ，创建出 实例对象</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><ol>
<li>Person.prototype也是一个对象，它有__proto__属性，属性值也是对象</li>
<li>Object是构造函数</li>
<li>构造函数 通过 prototype 访问到它的原型，实例通过 <strong>proto</strong> 访问到它的原型</li>
<li>正常的原型链终止到Object.prototype,  也就是Object.prototype.<strong>proto</strong> === null</li>
</ol>
<p>总结：原型链靠的是 <strong>proto</strong> 链接的</p>
]]></content>
  </entry>
  <entry>
    <title>子——&gt;父，父——&gt;子组件</title>
    <url>/2022/11/28/%E5%AD%90%E2%80%94%E2%80%94-%E7%88%B6%EF%BC%8C%E7%88%B6%E2%80%94%E2%80%94-%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="CSS中的scoped作用"><a href="#CSS中的scoped作用" class="headerlink" title="CSS中的scoped作用"></a>CSS中的scoped作用</h3><p>作用: 解决多个组件样式名相同, 冲突问题</p>
<p><strong>解决了组件内部的css样式影响外部文件的问题,style上加scoped, 组件内的样式只在当前vue组件生效</strong></p>
<p>在style上加入scoped属性, 就会在此组件的标签上加上一个随机生成的data-v-hash开头的属性。保证了必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到</p>
<h3 id="为什么要用组件"><a href="#为什么要用组件" class="headerlink" title="为什么要用组件"></a>为什么要用组件</h3><ol>
<li><p>复用组件，页面上有很多相同功能的内容，可以将其封装成一个个组件来加以复用</p>
</li>
<li><p>减少单个文件中的代码量，以便后续更具不同的功能在不同的文件中进行修改处理，极大的增加了代码的可读性</p>
</li>
</ol>
<p><strong>组件化</strong> ：封装的思想，把页面上 <code>可重用的部分</code> 封装为 <code>组件</code>，从而方便项目的 开发 和 维护</p>
<h3 id="父组件传递参数给子组件"><a href="#父组件传递参数给子组件" class="headerlink" title="父组件传递参数给子组件"></a>父组件传递参数给子组件</h3><ol>
<li><p>在父组件的子组件标签中，设置自定义属性，将需要传递的参数作为该属性的属性值</p>
</li>
<li><p>在子组件中，通过 props 属性进行接收( 注意事项: 接收的参数名称需要与父组件中的子组件标签中的属性名保存一致 )</p>
</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 父组件区域： </span><br><span class="line"></span><br><span class="line"> &lt;child 自定义属性=&quot;需要传递的参数&quot;&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line">子组件区域：</span><br><span class="line"></span><br><span class="line"> props: [ &#x27;自定义属性&#x27; ]</span><br></pre></td></tr></table></figure>

<h3 id="子组件传递参数给父组件"><a href="#子组件传递参数给父组件" class="headerlink" title="子组件传递参数给父组件"></a>子组件传递参数给父组件</h3><ol>
<li><p>在子组件中，通过 $emit(‘自定义事件名’, 需要传递的参数)</p>
</li>
<li><p>在父组件的子组件标签中, 设置自定义事件，并且为该事件绑定一个方法，在方法中可以获取到传递过来的参数</p>
</li>
</ol>
<p> （注意事项： 子组件中的自定义事件名 需要与 父组件中的子组件标签中的事件名保持一致 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件区域： </span><br><span class="line"></span><br><span class="line"> &lt;child @自定义事件名=&quot;绑定的方法&quot;&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"> 绑定的方法 (子组件传递过来的参数) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> 子组件区域：</span><br><span class="line"></span><br><span class="line"> function () &#123;</span><br><span class="line"></span><br><span class="line">  this.$emit(&#x27;自定义事件名&#x27;, 需要传递的参数)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于props的接收参数定义"><a href="#关于props的接收参数定义" class="headerlink" title="关于props的接收参数定义"></a>关于props的接收参数定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  自定义属性名称: &#123;</span><br><span class="line">    type: 当前数据的数据类型,</span><br><span class="line">    default: 默认值</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  str: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  num: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 0</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bool: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  arr: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default: () =&gt; []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  obj: &#123;</span><br><span class="line">    type: Object,</span><br><span class="line">    default: () =&gt; (&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>强缓存和协商缓存</title>
    <url>/2022/11/21/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="强缓存-强制缓存-过期时间"><a href="#强缓存-强制缓存-过期时间" class="headerlink" title="*强缓存*     强制缓存*过期时间*"></a><em><strong>*强缓存*</strong></em>     强制缓存<em><strong>*过期时间*</strong></em></h3><p><em><strong>*Cache-Control*</strong></em>****：****存在于响应头Response Headers中，控制强制缓存的逻辑</p>
<p>例如：Cache-Control: max-age = 31536000（单位是秒）最大过期时间</p>
<p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml1136\wps1.jpg" alt="img"> </p>
<p>初次请求，服务器会还回资源和Cache-Control 给客户端，再次请求时，先检查它的 cache-control 是否过期。</p>
<p>如果没有过期则直接从本地缓存中拉取资源，返回到客户端，而无需再经过服务器。</p>
<p>如果过期，着表示本地缓存失效，需要重新向服务器发起请求，之后服务器会再次返回资源和 cache-control 的值。</p>
<p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml1136\wps2.jpg" alt="img"> </p>
<h3 id="协商缓存-也叫对比缓存"><a href="#协商缓存-也叫对比缓存" class="headerlink" title="*协商缓存*   也叫对比缓存"></a><em><strong>*协商缓存*</strong></em>   也叫<em><strong>对比缓存</strong></em></h3><p>通过服务端来判断某件事情是不是可以被缓存（服务端判断客户端的资源，是否和服务端资源一样，如果一致则返回 304 ，反之返回 200 和最新的资源）</p>
<p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml1136\wps3.jpg" alt="img"> </p>
<p>第一次向服务器发出请求，则服务器返回资源和相对应的资源标识给浏览器。</p>
<p>第二次发送请求时，浏览器就会带上这个资源标识，服务端就会通过这个资源标识，可以判断出浏览器的资源跟服务端此时的资源是否一致，如果一致，则返回304，即表示Not Found 资源未修改。如果判断结果为不一致，则返回200，并返回资源以及新的资源标识。至此就结束了协商缓存的过程。</p>
<p>资源标识就是对当前所返回资源的一种唯一标识，可以是Etag或者是Last-Modified</p>
<ol>
<li>服务器会匹配浏览器发过来的 If-Modified-Since 是否和自己最后一次修改的 Last-Modified 的值相等，相等304，不等200，重新发送</li>
</ol>
<p>浏览器会通过 If-Modified-Since 的字段来保存 Last-Modified 的值，且 If-Modified-Since 保存在请求头当中</p>
<p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml1136\wps4.jpg" alt="img"> </p>
<ol start="2">
<li>服务器会匹配浏览器发过来的If-None-Match 是否和自己最后一次修改的 Etag 的值相等，相等304，不等200，重新发送</li>
</ol>
<p>浏览器会通过 If-None-Match 的字段来保存 Etag 的值，且 If-None-Match 保存在请求头当中<img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml1136\wps5.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>动态组件、组件缓存、组件插槽</title>
    <url>/2022/12/01/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E3%80%81%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98%E3%80%81%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p> 动态组件是 component /component 中 is属性，来设置当前需要展示的组件， 当前展示组件在components属性中注册的名称来作为is的属性值。 </p>
<p>=&gt; 以上效果与为每个组件标签设置v-if v-else-if v-else指令的表现效果一致</p>
<p>以上操作，每次切换时，都会删除旧的组件，并且加载新的组件，加载效率上是相对较低的，同时无法保留原来组件中设置的内容 =&gt; 为此，我们尝试将动态组件中的每个组件内容进行缓存操作</p>
<h3 id="组件缓存："><a href="#组件缓存：" class="headerlink" title="组件缓存："></a>组件缓存：</h3><p>目的：组件切换时会导致组件频繁的销毁和新建，所以很影响加载性能（时间），那么将切走的组件缓存到内存（空间）中下一次切换回来时直接从内存中读取即可</p>
<p>  在动态组件component 外设置keep-alive /keep-alive标签作为动态组件的父标签，那么，在 keep-alive 标签中包裹的组件，就能够进行缓存操作</p>
<p>  以上缓存操作带来的问题是: 引入组件缓存了，所有在组件创建时，以及组件销毁时需要做的一些操作，无法在缓存组件中进行正常执行。 由此出现了一个新的生命周期阶段 =&gt; 激活阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 点击切换两个不同的组件</span><br><span class="line">&lt;button @click=&quot;componentName = &#x27;UserInfo&#x27;&quot;&gt;用户密码&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;componentName = &#x27;UserName&#x27;&quot;&gt;个人简介&lt;/button&gt;</span><br><span class="line">// is中是那个组件，就显示那个组件</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">      &lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 引入</span><br><span class="line">import UserInfo from &#x27;../components/userInfo.vue&#x27;</span><br><span class="line">import UserName from &#x27;../components/userName.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;UserDynamic&#x27;,</span><br><span class="line">  // 注册</span><br><span class="line">  components: &#123;</span><br><span class="line">    UserInfo,</span><br><span class="line">    UserName</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      componentName: &#x27;UserInfo&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>问题： 如果有一些逻辑需要在组件切换到他时执行，或者有些定时器计时器需要在组件切换掉的时候关闭？？那该怎么做？</p>
<p>因为切换了，就意味着清除了，在下次打开时，就是重新创建，定时器这些就从头开始，没发正常记录时间，（deactivated - 失活）就可以让定时器暂停，等被切换回来时（activated - 激活），就再次启动</p>
<p>  结论： 如果这个组件是需要进行缓存的，那么将组件中created、mounted中的代码放到 activated 中，将beforeDestroy的代码放到deactivated中即可</p>
<h3 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a>组件插槽</h3><ol>
<li><h5 id="插槽的基本用法"><a href="#插槽的基本用法" class="headerlink" title="插槽的基本用法"></a>插槽的基本用法</h5><p>  1.1 在子组件的目标位置，设置slot, 作为后续父组件插入的目标坐标</p>
<p>  1.2 在父组件的子组件双标签中，设置需要插入的自定义内容（标签、文本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父：</span><br><span class="line">&lt;MyPannel&gt;</span><br><span class="line">	&lt;img src=&quot;../assets/mm.gif&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">    &lt;span&gt;这是父组件插入的文本&lt;/span&gt;</span><br><span class="line">&lt;/MyPannel&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyPannel from &#x27;../components/myPannel.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;UserSlot&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyPannel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">子：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  	  &lt;slot&gt;</span><br><span class="line">  	  //插入的标签再这里</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><h5 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h5></li>
<li><p>1 在子组件中，的slot双标签内，设置默认的标签格式， 如果父组件在使用子组件时，不去设置对应的插槽内容时，就展示默认值</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父：</span><br><span class="line">&lt;MyPannel&gt;</span><br><span class="line">&lt;/MyPannel&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyPannel from &#x27;../components/myPannel.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;UserSlot&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyPannel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">子：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  	  &lt;slot&gt;</span><br><span class="line">        &lt;div&gt;这是一个默认值&lt;/div&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><h5 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h5><p>当子组件中有多个位置需要使用插槽时，需要用到具名插槽，为每个位置的slot起个名字</p>
</li>
<li><ol>
<li>在子组件中的 slot 标签上创建 name 属性</li>
</ol>
</li>
<li><ol start="2">
<li>在父组件的子组件双标签内，设置模板标签template, 在模板标签中，设置 v-slot:插槽名称 的指令，那么这个模板标签template中包裹的内容就会设置到对应的子组件 slot 插槽位置上<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父：</span><br><span class="line">&lt;MyPannel&gt;</span><br><span class="line">	 &lt;template v-slot:title&gt;</span><br><span class="line">        &lt;span&gt;猫猫折叠面板&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;template v-slot:content&gt;</span><br><span class="line">        &lt;img src=&quot;../assets/mm.gif&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;span&gt;这是父组件插入的文本&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">&lt;/MyPannel&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyPannel from &#x27;../components/myPannel.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;UserSlot&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyPannel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">子：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  	  &lt;slot name=&quot;title&quot; &gt;</span><br><span class="line">  	  //插入的标签再这里</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">      &lt;slot name=&quot;content&quot; &gt;</span><br><span class="line">  	  //插入的标签再这里</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<ol start="4">
<li><h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5></li>
</ol>
<p>  当父组件需要用到一些对应插槽子组件提供的数据时，可以用到作用域插槽来获取数据</p>
<p>  4.1. 发送数据: 在子组件中，slot标签上，设置 自定义属性， 需要传递的数据作为该属性的值</p>
<p>  4.2. 接收数据: 在父组件的子组件对应插槽中，通过 #插槽名称=”自定义变量” 该变量就包含了所有在slot标签中设置的自定义属性的值，通过点语法的形式来进行使用即可 （一般情况下，这个自定义变量我们用 scope 来表示）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父：</span><br><span class="line">&lt;MyPannel&gt;</span><br><span class="line">	&lt;MyPannel&gt;</span><br><span class="line">      &lt;!-- 需要展示张三的名称和年龄，而数据都在子组件中 --&gt;</span><br><span class="line">      &lt;template v-slot:content=&quot;scope&quot;&gt;</span><br><span class="line">        &lt;div&gt;对象: 双&#123; scope.myObj 双&#123;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;名字：双&#123; scope.myObj.name 双&#123;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;年龄：双&#123; scope.myObj.age 双&#123;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;字符串: 双&#123; scope.myStr 双&#123;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;数字: 双&#123; scope.myNum 双&#123;&lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/MyPannel&gt;</span><br><span class="line">&lt;/MyPannel&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyPannel from &#x27;../components/myPannel.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;UserSlot&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyPannel</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">子：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  	 &lt;slot name=&quot;content&quot; :myObj=&quot;obj&quot; :myStr=&quot;str&quot; :myNum=&quot;num&quot;&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: &#x27;zhangsan&#x27;,</span><br><span class="line">        age: 20</span><br><span class="line">      &#125;,</span><br><span class="line">      str: &#x27;helloWorld&#x27;,</span><br><span class="line">      num: 123321</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>改变this指向的三个方法</title>
    <url>/2022/11/20/%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>this在定义的时候不能确定, 只有执行调用的时候才能确定(箭头函数除外).!!! 重要</p>
<ol>
<li>全局作用域中 / 普通函数中 / 定时器里面  this 指向 window</li>
<li>方法调用中, 谁调用这个方法, this指向谁</li>
<li>事件注册的时候, this指向被绑定的元素</li>
<li>构造函数中, this 指向的是 构造函数的实例</li>
</ol>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol>
<li><p>箭头函数没有prototype ,没有原型</p>
</li>
<li><p>不能使用new调用箭头函数，也就是它不能作为构造函数</p>
</li>
<li><p>箭头函数没有arguments对象，可以利用rest接收剩余参数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = (first, ...rest) =&gt; &#123;</span><br><span class="line">    console.log(first, rest)  123  [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">a(123, 1, 2, 3)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>箭头函数本身没有this，并且在定义的时候就确定了</p>
<p>===&gt;   指向上层作用域中的this</p>
</li>
</ol>
<h2 id="改变this指向的三个方法"><a href="#改变this指向的三个方法" class="headerlink" title="改变this指向的三个方法"></a>改变this指向的三个方法</h2><h4 id="1-Function-prototype-call-函数的方法"><a href="#1-Function-prototype-call-函数的方法" class="headerlink" title="1.Function.prototype.call()      函数的方法"></a>1.Function.prototype.call()      函数的方法</h4><p>语法：funtion.call(thisArg, 参数1, 参数2, 参数3…) </p>
<p>第一个参数：thisArg   是this指向的对象</p>
<p>第一个参数后：参数1, 参数2, 参数3…   是参数列表</p>
<p>​     // 1.改变this指向</p>
<p>​    // 2.会调用函数,立即执行,还回函数调用结果</p>
<p>​    // 3.第一个参数就是让this指向的对象</p>
<p>​    // 后面紧跟着的是参数列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">            name: &quot;123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        const cbc = &#123;</span><br><span class="line">            name: &quot;456&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        function fn(x, y) &#123;</span><br><span class="line">            console.log(this)   // 456</span><br><span class="line">            return x + y</span><br><span class="line">        &#125;</span><br><span class="line">        const res = fn(cbc, 1, 3)</span><br><span class="line">        console.log(res)  //  4</span><br></pre></td></tr></table></figure>

<h4 id="2-Function-prototype-apply-函数的方法"><a href="#2-Function-prototype-apply-函数的方法" class="headerlink" title="2.Function.prototype.apply()     函数的方法"></a>2.Function.prototype.apply()     函数的方法</h4><p>语法：fn.apply(this指向,[数组])</p>
<p>第一个参数：this指向的对象</p>
<p>第一个参数后：数组</p>
<p>​    // 1.改变this指向</p>
<p>​    // 2.调用函数,立即执行</p>
<p>​    // 3.还回值就是函数本身的返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    msg: &#x27;hello&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const abc = &#123;</span><br><span class="line">    demo: &#x27;哈哈哈哈&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function fn(x, y) &#123;</span><br><span class="line">    console.log(this)   //哈哈哈哈</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">const res = fn.apply(abc,[1,3])</span><br><span class="line">console.log(res)   //4</span><br></pre></td></tr></table></figure>

<h4 id="3-Function-prototype-bind"><a href="#3-Function-prototype-bind" class="headerlink" title="3.Function.prototype.bind()"></a>3.Function.prototype.bind()</h4><p>创建的是一个新的函数（称为绑定函数）</p>
<p>该方法并不会调用函数，仅仅改变了<strong>this</strong>指向</p>
<p>语法：funtion.bind(thisArg, 参数1, 参数2, 参数3…) </p>
<p>第一个参数：thisArg：  this指向的对象</p>
<p>第一个参数后：参数1, 参数2, 参数3…     是参数列表</p>
<h4 id="三者的区别："><a href="#三者的区别：" class="headerlink" title="三者的区别："></a>三者的区别：</h4><p>call（）          既可以调用函数又可以传参数，参数用逗号隔开</p>
<p>apply（）      既可以调用函数又可以传参数，参数用一个数组包裹</p>
<p>bind（）        不可以调用函数，可以传参数，参数用逗号隔开，返回一个新的函数</p>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器垃圾回收机制</title>
    <url>/2022/11/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>JS中内存的分配和回收是自动完成的，内存在不使用的时候会被JS引擎/垃圾回收程序回收<br>内存泄露：不在使用的内存，没有及时释放掉<br>两种垃圾回收的方法：1.引用计数法（淘汰） 2.标记清除法（主流）<br>        ==&gt; 引用计数法<br>                // 1. 跟踪记录每个值被引用的次数<br>                // 2. 如果这个值被引用了一次，那么就记录次数1<br>                // 3. 多次引用会累加<br>                // 4. 如果减少一个引用就减少1<br>                // 5. 如果引用次数是0，则释放内存<br>        ==&gt; 标记清除法<br>                // 1. 标记阶段：标记空间中的活动对象和非活动对象<br>                // 2. 清除阶段：回收非活动对象（销毁非活动对象）</p>
<p>对比:<br>引用计数法并不是周期性的垃圾回收，什么时候引用次数为0了，直接回收<br>周期性进行垃圾回收，只要是未标记到的，都清除掉</p>
<p>引用计数法的内存泄漏：如果两个对像相互引用，引用次数一直不为0，会造成内存泄漏<br>标记清除法缺陷：内存碎片化，回收了的内存，不会移动，在哪里清除的，内存就在那里，不会打回收的和没有回收分开存储</p>
<p>为了优化标记清除法的缺陷，就有了标记整理算法，对回收后的内存进行了整理，将回收的和没有回收的，分成两个大类<br>        ===&gt; 标记整理算法（Mark-Compact）现在叫标记整理算法，是标记清除法的升级版<br>                // 1. 标记空间中活动对象和非活动对象<br>                // 2. 回收非活动对象所占用的内存<br>                // 3. 内存整理</p>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2022/11/20/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h4 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h4><p>新旧对象的共享同一块内存空间</p>
<p>在堆里新开辟一个内存空间，创建一个新的对象，存储新的对象</p>
<p>===&gt;  拷贝源对象的第一层基本数据类型的<strong>值</strong>和引用类型的<strong>地址</strong></p>
<p>1.基本数据类型：拷贝后的变量存储在不同的空间，互不影响</p>
<p>2.引用数据类型：拷贝后的变量里面存储的是，引用数据类型的地址指向同一个空间的数据，互相会影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">     name: &#x27;ssss&#x27;,</span><br><span class="line">     book: &#123;</span><br><span class="line">         title: &quot;you don&#x27;t know JS&quot;,</span><br><span class="line">         price: &quot;300$&quot;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> let obj2 = Object.assign(&#123;&#125;, obj)</span><br><span class="line"> console.log(obj2.name === obj.name) //false  //比较值和数据类型</span><br><span class="line"> console.log(obj2.book === obj.book) //true   //引用类型.看地址是否一样</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h4><p>在堆里面开辟一个新的内存空间，创建一个新的对象，存储的新的对象</p>
<p>===&gt;  递归的拷贝源对象的所有属性和方法，拷贝前后的两个对象，互不影响</p>
<p>===&gt;  递归拷贝：一层一层的拷贝，每一层都创建一个新的内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a1 = &#123;b: &#123;c: &#123;&#125;&#125; &#125;</span><br><span class="line">let a3 = deepClone(a1)  // deepClone表示深拷贝的一些方法</span><br><span class="line">console.log(a3.b.c === a1.b.c) // false</span><br></pre></td></tr></table></figure>

<h2 id="浅，深拷贝的实现方式"><a href="#浅，深拷贝的实现方式" class="headerlink" title="浅，深拷贝的实现方式"></a>浅，深拷贝的实现方式</h2><h5 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1. Object.assign()"></a>1. Object.assign()</h5><p>Object.assign(目标对象，源对象) 接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象自身的可枚举属性合并到目标对象中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;,sports:&#x27;basketball&#x27; &#125;;</span><br><span class="line">let obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.person.name = &quot;wade&quot;;</span><br><span class="line">obj2.sports = &#x27;football&#x27;</span><br><span class="line">console.log(obj1); // &#123; person: &#123; name: &#x27;wade&#x27;, age: 41 &#125;, sports: &#x27;basketball&#x27; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-扩展运算符-…"><a href="#2-扩展运算符-…" class="headerlink" title="2.扩展运算符 …"></a>2.扩展运算符 …</h5><p>扩展运算符是一个 es6/es2015 特性.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; name: &#x27;Kobe&#x27;, address:&#123;x:100,y:100&#125;&#125;</span><br><span class="line">let obj2= &#123;...obj1&#125;</span><br><span class="line">obj1.address.x = 200;</span><br><span class="line">obj1.name = &#x27;wade&#x27;</span><br><span class="line">console.log(obj2) // &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-Array-prototype-concat-合并数组"><a href="#3-Array-prototype-concat-合并数组" class="headerlink" title="3.Array.prototype.concat()   合并数组"></a>3.Array.prototype.concat()   合并数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [1,2,&#123;user:&#x27;杰伦&#x27;&#125;]</span><br><span class="line">const arr2 = arr1.concat()</span><br><span class="line">arr2[0] =666</span><br><span class="line">arr2[2].user = &#x27;ll&#x27;</span><br><span class="line">console.log(arr1)   //[1,2,&#123;user:&#x27;ll&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<h5 id="4-Array-prototype-slice-a，b-剪切，遵循前闭后开的原则-a-b-包含a不包含b"><a href="#4-Array-prototype-slice-a，b-剪切，遵循前闭后开的原则-a-b-包含a不包含b" class="headerlink" title="4.Array.prototype.slice(a，b)  剪切，遵循前闭后开的原则[a,b),包含a不包含b"></a>4.Array.prototype.slice(a，b)  剪切，遵循前闭后开的原则[a,b),包含a不包含b</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [ 1, 3, &#123;username: &#x27;kobe&#x27;&#125; ];</span><br><span class="line">let arr3 = arr.slice();</span><br><span class="line">arr3[2].username = &#x27;wade&#x27;</span><br><span class="line">console.log(arr); // [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-函数库-lodash-的-clone-方法"><a href="#5-函数库-lodash-的-clone-方法" class="headerlink" title="5.函数库 lodash 的 _.clone 方法"></a>5.函数库 lodash 的 _.clone 方法</h5><h4 id="深拷贝的实现方法："><a href="#深拷贝的实现方法：" class="headerlink" title="深拷贝的实现方法："></a>深拷贝的实现方法：</h4><h5 id="1-JSON-parse-JSON-stringify"><a href="#1-JSON-parse-JSON-stringify" class="headerlink" title="1.JSON.parse(JSON.stringify())"></a>1.JSON.parse(JSON.stringify())</h5><p>这也是利用 JSON.stringify 将对象转成 JSON 字符串，再用 JSON.parse 把字符串解析成对象，一去一来，新的对象产生了，而且堆内存中会开辟出一个新的区域存放新对象，实现深拷贝。</p>
<p>注意：</p>
<p><strong>这种方法虽然可以实现数组或对象深拷贝，但不能处理函数和正则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [ 1, 3, &#123;username: &#x27;kobe&#x27;&#125; ];</span><br><span class="line">let arr4 = JSON.parse(JSON.stringify(arr));</span><br><span class="line">arr4[2].username = &#x27;duncan&#x27;; </span><br><span class="line">console.log(arr)   //[ 1, 3, &#123;username: &#x27;kobe&#x27;&#125; ]</span><br><span class="line">console.log(arr4)  //[ 1, 3, &#123;username: &#x27;duncan&#x27;&#125; ]</span><br></pre></td></tr></table></figure>

<h5 id="2-jQuery-extend-方法"><a href="#2-jQuery-extend-方法" class="headerlink" title="2.jQuery.extend() 方法"></a>2.jQuery.extend() 方法</h5><p>jquery 有提供一个<code>$.extend</code>可以用来做 深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.extend(deepCopy, target, object1, [objectN])  //第一个参数为true,就是深拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var $ = require(&#x27;jquery&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = $.extend(true, &#123;&#125;, obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f); // false</span><br></pre></td></tr></table></figure>

<h5 id="3-函数库-lodash-的-cloneDeep-方法"><a href="#3-函数库-lodash-的-cloneDeep-方法" class="headerlink" title="3.函数库 lodash 的 _.cloneDeep 方法"></a>3.函数库 lodash 的 _.cloneDeep 方法</h5><p>该函数库也有提供 _.cloneDeep 用来做 Deep Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);// false</span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归:自己调用自己</p>
<p>缺点：递归爆栈(栈溢出)</p>
<p>栈 ===&gt; 数据结构,先进后出的特征,栈有自己得到深度,超出了就会栈溢出了</p>
<p>递归的终止条件,一般写在第二次调用前,return也可以终止函数的执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">function count()&#123;</span><br><span class="line">    i++</span><br><span class="line">    console.log(`$&#123;i&#125;`)</span><br><span class="line">    if(i &gt;= 1000)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    count()</span><br><span class="line">&#125;</span><br><span class="line">count()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>生命周期，ref</title>
    <url>/2022/11/30/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8Cref/</url>
    <content><![CDATA[<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>4个阶段（初始化，挂载，更新，销毁），每个阶段前后各一个方法，8个方法</p>
<ol>
<li><p>初始化前 - 初始化数据与方法之前，此时，无法访问组件内部的方法与数据</p>
</li>
<li><p>created  初始化后 （常用生命周期函数） - 是整个组件中，最早 可以访问数据与方法的函数，</p>
<p>=&gt;   此时真实dom元素并没有创建，无法进行任何dom操作</p>
</li>
<li><p>挂载前 - dom挂载到页面之前，也无法获取到dom元素，它能做的事情与created一致，但是时间上靠后</p>
</li>
<li><p>mounted  挂载后（常用） - 在这个时期，dom元素以及挂载成功了，可以获取到dom元素，操作页面</p>
</li>
<li><p>页面更新前 - 数据是新的，页面是旧的</p>
</li>
<li><p>页面更新后 - 数据是新的，页面也是新的</p>
</li>
<li><p>销毁前 （常用） - 在这个时机，依然可以使用组件中的数据与方法， 需要在销毁前删除这个组件中设置的异步操作(主要是定时器)</p>
</li>
<li><p>销毁后 - 销毁后，无法做任何事情，和初始化前很相似，都坐不了任何事</p>
</li>
</ol>
<h5 id="更新阶段的问题及解决"><a href="#更新阶段的问题及解决" class="headerlink" title="更新阶段的问题及解决"></a>更新阶段的问题及解决</h5><p>问题： 当在更新阶段，对数据又进行了操作时，又会重新将进入更新阶段，所以以此往复会无限循环下去</p>
<p>解决方案：不要去使用更新阶段的2个钩子函数，watch监听器同样可以监听到数据的改变，所以使用watch来做更新阶段的操作</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><pre><code>1. 4个阶段（初始化，挂载，更新，销毁），每个阶段的前后都有一个钩子函数
2. created 当数据与方法初始化完成后执行的函数，此时可以在当前函数中使用方法与数据 - 常用来在这个阶段获取后端数据
3. mounted 当真实dom挂载到页面上之后执行的函数，此时可以在函数中操作dom，并且可以执行所有在created中执行的所有逻辑
     =&gt; 如果一个方法很难判断在created或者是mounted中执行时，直接放到mounted中即可
4. 更新阶段的2个函数 存在 死循环数据更新 的问题，所以如果需要监听某个数据发生的变化时，用watch监听器来代替更新阶段的钩子函数
5. 如果当前组件中定义了全局的异步操作(定时器)，那么在销毁前 beforeDestroy 时需要主动关闭这些异步操作
</code></pre>
<h3 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="ref和$refs"></a>ref和$refs</h3><p>用法1：</p>
<p>   ref 与 $refs 来获取dom元素</p>
<p>   ref 是标签中的一个属性（与id来进行联合记忆）</p>
<p>   $refs是vue的实例方法   ，来获取到dom元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; ref=&quot;refDemo&quot;&gt;这一个dom元素&lt;/div&gt;</span><br><span class="line">&lt;div ref=&quot;ref-demo2&quot;&gt;这一个dom元素&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> mounted () &#123;</span><br><span class="line"> 	console.log(document.querySelector(&#x27;#demo&#x27;))</span><br><span class="line"> 	console.log(this.$refs.refDemo)</span><br><span class="line"> 	console.log(this.$refs[&#x27;ref-demo2&#x27;])  // 如果名字中有短横线</span><br><span class="line"> 	// 三者都是获取元素</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>用法2：</p>
<p>   ref 与 $refs 来获取子组件vue实例</p>
<p>   可以通过$refs来获取子组件的数据和方法，并进行使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Child from &#x27;./子组件.vue&#x27;</span><br><span class="line">    export default &#123;</span><br><span class="line">         components: &#123;</span><br><span class="line">             Child	</span><br><span class="line">         &#125;,</span><br><span class="line">          mounted () &#123;</span><br><span class="line"> 	           this.$refs.child.getMassage(&#x27;123&#x27;)</span><br><span class="line">               this.$refs.child.setMsg(&#x27;父组件向要修改的内容&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><p>因为vue监测数据更新, 开启一个DOM更新队列(异步任务)，所以会造成有些方法会在Dom更新之前执行，得到的也是更新之前的数据（这样肯定不行）</p>
<p>解决办法：为这些需要在dom更新后才执行的方法放到 $nextTick()中， 它就会在dom更新后在执行</p>
<p>使用流程： 可以先使用$nextTick解决dom更新的异步问题，如果无法获取到dom元素时，改为 setTimeout(),当然也可以直接使用setTimeout()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123; </span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btn()&#123;</span><br><span class="line">      this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务)</span><br><span class="line"></span><br><span class="line">      console.log(this.$refs.myP.innerHTML) // 0</span><br><span class="line"></span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this.$refs.myP.innerHTML, &#x27;setTimeout&#x27;)</span><br><span class="line">      &#125;, 0)</span><br><span class="line"></span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        console.log(this.$refs.myP.innerHTML, &#x27;$nextTick&#x27;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 打印结果是：</span><br><span class="line">// 0   </span><br><span class="line">// 1，$nextTick  </span><br><span class="line">// 1，setTimeout</span><br><span class="line"></span><br><span class="line">// 所以setTimeout在$nextTick后执行</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>路由配置，声明式导航传参、编程式导航传参，路由守卫</title>
    <url>/2022/12/02/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%BC%A0%E5%8F%82%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%BC%A0%E5%8F%82%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h3 id="路由的配置"><a href="#路由的配置" class="headerlink" title="路由的配置"></a>路由的配置</h3><ol>
<li><p>安装vue-router依赖 npm i <a href="mailto:&#118;&#117;&#x65;&#x2d;&#114;&#111;&#x75;&#x74;&#101;&#x72;&#64;&#x33;&#46;&#x35;&#46;&#49;">&#118;&#117;&#x65;&#x2d;&#114;&#111;&#x75;&#x74;&#101;&#x72;&#64;&#x33;&#46;&#x35;&#46;&#49;</a></p>
</li>
<li><p>引入路由 import VueRouter from ‘vue-router’</p>
</li>
<li><p>让Vue构造函数使用该依赖 Vue.use(VueRouter)</p>
</li>
<li><p>创建路由规则数组<br>  4.1 引入组件</p>
<pre><code>4.2 创建规则数组让 组件与路由地址产生联系 const routes = [&#123; path, component &#125;]
</code></pre>
</li>
<li><p>实例化路由对象 const router = new VueRouter({ routes })</p>
</li>
<li><p>在实例化Vue过程中，引入关联路由对象 new Vue({ router, … })</p>
</li>
<li><p>在页面上使用时，设置挂载点。 router-view, 该标签所在的位置，就是路由绑定页面组件所展示的位置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在main.js中</span><br><span class="line">// 1. (固定)安装路由依赖 npm i vue-router@3.5.1</span><br><span class="line">// 注意事项： 在下载是必须输入版本后缀，因为 vue2 =&gt; router@3.x.x  vue3 =&gt; router@4.x.x</span><br><span class="line"></span><br><span class="line">// 2. (固定)在main.js中导入路由</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">// 3. (固定)通过 Vue构造函数的 use() 静态方法，使用路由</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 4. 创建路由规则数组 - 规则指的是：建立路由与页面组件的一一对应关系</span><br><span class="line">// 4.1 引入页面组件</span><br><span class="line">import Find from &#x27;./views/Find.vue&#x27;</span><br><span class="line">import My from &#x27;./views/My.vue&#x27;</span><br><span class="line">import Part from &#x27;./views/Part.vue&#x27;</span><br><span class="line">import NotFound from &#x27;./views/notFound.vue&#x27;</span><br><span class="line">// 4.2 创建规则</span><br><span class="line">// 注意事项：一般情况下，组件名称和路由名称保持单词一致</span><br><span class="line">//          每个大括号中都是一组路由与组件的对应关系</span><br><span class="line">//          数组的命名，尽量固定为 routes</span><br><span class="line">const routes = [</span><br><span class="line">  // 路由对象：在其中建立路由与组件的对应联系</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;, // 默认根路由</span><br><span class="line">    redirect: &#x27;/find&#x27; // 重定向属性，当网页路由为 / 时，会自动的跳转到 /find 路由上</span><br><span class="line">  &#125;,</span><br><span class="line">  // 什么情况下，需要展示404页面 =&gt; 在路由规则数组中匹配不到任意一个规则时</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;*&#x27;, // * 表示的是，除其他规则外的所有地址</span><br><span class="line">    component: NotFound</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/find&#x27;, // 路由</span><br><span class="line">    name: &#x27;find&#x27;,</span><br><span class="line">    component: Find, // 组件</span><br><span class="line">    children: [ // 二级路由数组</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;recommend&#x27;,</span><br><span class="line">        component: Recommend</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;ranking&#x27;,</span><br><span class="line">        component: Ranking</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;songList&#x27;,</span><br><span class="line">        component: SongList</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/my&#x27;, // 路由</span><br><span class="line">    name: &#x27;my&#x27;,</span><br><span class="line">    component: My // 组件</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/part&#x27;, // 路由</span><br><span class="line">    name: &#x27;part&#x27;,</span><br><span class="line">    component: Part // 组件</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  // 4.5 可以过滤到路由抛出的错误异常 =&gt; 将路由跳转时抛出的异常给屏蔽掉</span><br><span class="line">const originalPush = VueRouter.prototype.push</span><br><span class="line">VueRouter.prototype.push = function push (location) &#123;</span><br><span class="line">  return originalPush.call(this, location).catch(err =&gt; err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> // 5. (固定)创建实例化路由对象 - 传入规则</span><br><span class="line"> const router = new VueRouter(&#123;</span><br><span class="line"> routes,</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> // 5.5 创建完路由实例后，可以设置路由守卫</span><br><span class="line"> /* </span><br><span class="line">  路由前置守卫 beforeEach</span><br><span class="line">  语法: </span><br><span class="line">  router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    to: 要跳转到那个路由地址 - 目标</span><br><span class="line">    from: 从哪里跳转过去 - 来源</span><br><span class="line">    next: 接下来该干嘛（1. 阻止跳转，    2. 正常跳转    3. 改变跳转） - 行为</span><br><span class="line">      =&gt;                next(false)    next(true)     next(&#x27;/改变跳转的路由地址&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">*/</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(to, from)</span><br><span class="line">  // 1. 如果是从 /my 跳转到 /part 时，阻止跳转</span><br><span class="line">  if (from.path === &#x27;/my&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(false)</span><br><span class="line">    // 2. 如果从 /find 跳转到 /part时，转为跳转到 /my</span><br><span class="line">  &#125; else if (from.path === &#x27;/find&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(&#x27;/my&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123; // 实例化Vue对象（传入配置对象）</span><br><span class="line">  // 6. (固定)将路由关联到vue实例中</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App), // render渲染： 告诉vue需要渲染什么东西（渲染根组件）</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;) // 渲染到哪里 =&gt; 将根组件中的内容，替换index.html中id为app的标签</span><br><span class="line"></span><br><span class="line">在app.vue中</span><br><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;!-- 7. 设置挂载点-当url的hash值路径切换, 显示规则里对应的组件到这 --&gt;</span><br><span class="line">      &lt;!-- router-view的作用与 component动态组件的作用是一样的，都是确定了展示组件的位置坐标</span><br><span class="line">       --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="声明式导航-通过标签进行路由跳转"><a href="#声明式导航-通过标签进行路由跳转" class="headerlink" title="声明式导航 - 通过标签进行路由跳转"></a>声明式导航 - 通过标签进行路由跳转</h3><h5 id="router-link-标签，替换a标签来实现路由跳转"><a href="#router-link-标签，替换a标签来实现路由跳转" class="headerlink" title="router-link 标签，替换a标签来实现路由跳转"></a>router-link 标签，替换a标签来实现路由跳转</h5><p>总结 router-link 标签与 a标签 的区别</p>
<ol>
<li><p>虽然在vue模板中写作 router-link, 但是在真实dom挂载后本质上是 a标签</p>
</li>
<li><p>to 属性 代替了 href属性 进行页面跳转</p>
</li>
<li><p>to属性后面接的路由地址不必带 # 号</p>
</li>
<li><p>router-link 自带了2个class类名 router-link-exact-active / router-link-active</p>
<p>​      =&gt; 这两个类可以作为路由导航的高亮类名来使用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#/part&quot;&gt;朋友&lt;/a&gt;</span><br><span class="line">上下效果一样</span><br><span class="line">&lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part?userName=小坤&quot;&gt;朋友A&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part/东东&quot;&gt;朋友B&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h5 id="声明式导航传参的两种方式"><a href="#声明式导航传参的两种方式" class="headerlink" title="声明式导航传参的两种方式"></a>声明式导航传参的两种方式</h5><p>1.to=”/路由地址?参数名1=参数值1&amp;参数名2=参数值2”</p>
<p>​     =&gt; 接收: 在对应组件中， 以 $route.query.参数名 的形式进行接收对应参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;router-link to=&quot;/part?userName=小坤&quot;&gt;朋友A&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part/东东&quot;&gt;朋友B&lt;/router-link&gt;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;query接收参数： 双&#123; $route.query.userName 双&#123;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;params接收参数： 双&#123; $route.params.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2.to=”/路由地址/参数值”</p>
<p>​      在路由规则数组的对应路由地址中，需要设置 path: ‘/路由地址/:参数名’</p>
<p>​     =&gt; 接收：在对应组件中，以 $route.params.参数名 的形式进行接收对应参数</p>
<p> 注意事项： 如果使用 /路由地址/参数值 的传参方式，那么原本正常的不传参的路由将无法被访问到</p>
<p>​     解决办法:  可以再创建一个没有传参要求的路由规则</p>
<p>第一种方法的优势：</p>
<ol>
<li><p>传参代码都在一个文件中，方便阅读</p>
</li>
<li><p>方法二需要重新创建一个带有传参规则的路由规则对象，麻烦</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;router-link to=&quot;/part?userName=小坤&quot;&gt;朋友A&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part/东东&quot;&gt;朋友B&lt;/router-link&gt;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;query接收参数： 双&#123; $route.query.userName 双&#123;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;params接收参数： 双&#123; $route.params.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编程式导航-通过js来进行路由跳转"><a href="#编程式导航-通过js来进行路由跳转" class="headerlink" title="编程式导航 - 通过js来进行路由跳转"></a>编程式导航 - 通过js来进行路由跳转</h3><p> 注意事项： 编程式导航会遇到一个小问题，当处在A路由上时，想用编程式导航跳转到A路由，会报出错误阻止你重复的跳转<br>        传参特点：</p>
<pre><code>         1. path跳转用query发送数据， name跳转用params发送数据
         2. query传参会拼接到url上，而params传参不会拼接到url上
         3. 通过编程式导航的params传参，如果刷新页面，传递的数据会消失
         4. name也可以使用query传参，但为了保证代码的统一性，尽量不要使用这种传参方式
</code></pre>
<h5 id="编程式导航的传参的两种方法"><a href="#编程式导航的传参的两种方法" class="headerlink" title="编程式导航的传参的两种方法"></a>编程式导航的传参的两种方法</h5><ol>
<li>this.$router.push({</li>
</ol>
<p>​     path: ‘/路由地址’, // 需要跳转到的路由地址</p>
<p>​     query: {} // path跳转用query来发送数据</p>
<p>​    })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;span @click=&quot;goPath(&#x27;/part&#x27;, &#x27;part&#x27;)&quot;&gt;朋友A&lt;/span&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> methods: &#123;</span><br><span class="line">    // 通过path属性进行跳转</span><br><span class="line">    goPath (myPath, myName) &#123;</span><br><span class="line">      console.log(myPath, myName)</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">        path: myPath,</span><br><span class="line">        query: &#123;</span><br><span class="line">          userName: &#x27;东东&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;query接收参数： 双&#123; $route.query.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>this.$router.push({</li>
</ol>
<p>​     name: ‘路由名称’, // 在路由规则数组中配置的路由名称</p>
<p>​     params: {} // name跳转用params发送数据</p>
<p>​    })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;span @click=&quot;goName(&#x27;/part&#x27;, &#x27;part&#x27;)&quot;&gt;朋友B&lt;/span&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> methods: &#123;</span><br><span class="line">    // 通过name属性进行跳转</span><br><span class="line">    goName (myPath, myName) &#123;</span><br><span class="line">      console.log(myPath, myName)</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">        name: myName,</span><br><span class="line">        params: &#123;</span><br><span class="line">          userName: &#x27;欢欢&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;params接收参数： 双&#123; $route.params.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p> 路由与路由之间也可能存在嵌套关系</p>
<p>注意事项：</p>
<p>​     1. 要明确一级路由、二级路由等等他们的挂载点到底在那个组件上，在对应组件中设置router-view</p>
<p>​     2. 非一级路由的规则对象中path属性不可以添加 ‘/‘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法： 如果两个页面组件存在路由的嵌套关系，那么可以在路由规则数组中以children属性定义嵌套</span><br><span class="line">          &#123;</span><br><span class="line">            path: &#x27;/一级路由&#x27;,</span><br><span class="line">            component: &#x27;外层组件&#x27;,</span><br><span class="line">            children: [</span><br><span class="line">              &#123;</span><br><span class="line">                path: &#x27;二级路由&#x27;,</span><br><span class="line">                component: &#x27;内层组件&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">使用是要把一级路由二级路由....后续的所有联系拼接好后作出跳转</span><br><span class="line">to=&quot;/一级路由/二级路由/...&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路由配置4.2中</span><br><span class="line">const routes = [</span><br><span class="line">      &#123;</span><br><span class="line">    path: &#x27;/find&#x27;, // 路由</span><br><span class="line">    name: &#x27;find&#x27;,</span><br><span class="line">    component: Find, // 组件</span><br><span class="line">    children: [ // 二级路由数组</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;recommend&#x27;,</span><br><span class="line">        component: Recommend</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">在一级路由中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link to=&quot;/find/recommend&quot;&gt;推荐&lt;/router-link&gt;</span><br><span class="line">    &lt;div style=&quot;border: 1px solid red;&quot;&gt;</span><br><span class="line">      &lt;!-- 二级路由的挂载点 --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由前置守卫-beforeEach"><a href="#路由前置守卫-beforeEach" class="headerlink" title="路由前置守卫 beforeEach"></a>路由前置守卫 beforeEach</h3><p>创建完路由实例后（配置路由第5点后），可以设置路由守</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法: </span><br><span class="line">  router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    to: 要跳转到那个路由地址 - 目标</span><br><span class="line">    from: 从哪里跳转过去 - 来源</span><br><span class="line">    next: 接下来该干嘛（1. 阻止跳转，    2. 正常跳转    3. 改变跳转） - 行为</span><br><span class="line">      =&gt;                next(false)    next(true)     next(&#x27;/改变跳转的路由地址&#x27;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(to, from)</span><br><span class="line">  // 1. 如果是从 /my 跳转到 /part 时，阻止跳转</span><br><span class="line">  if (from.path === &#x27;/my&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(false)</span><br><span class="line">    // 2. 如果从 /find 跳转到 /part时，转为跳转到 /my</span><br><span class="line">  &#125; else if (from.path === &#x27;/find&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(&#x27;/my&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// next(true) === next()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>过滤器、computed计算属性、watch监听器</title>
    <url>/2022/11/26/%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81watch%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h3 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h3><p>语法：</p>
<p>​    全局定义过滤器</p>
<p>​     在 main.js 中，通过 Vue.filter 静态方法</p>
<p>​     Vue.filter(‘自定义过滤器名称 - 驼峰式命名’, (需要过滤的值 - 必填且默认, 使用过滤器时传递进来的参数) =&gt; {</p>
<p>​      …函数执行体</p>
<p>​      return 返回处理后的值</p>
<p>​     })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.js</span><br><span class="line">// 创建将所有字母大写的过滤器</span><br><span class="line">Vue.filter(&#x27;toUp&#x27;, (value) =&gt; &#123;</span><br><span class="line">  // value：需要进行过滤的默认值</span><br><span class="line">  return value.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.vue</span><br><span class="line">&lt;div&gt;全局过滤器：&#123;&#123; str | toUp &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>局部定义过滤器 - 在哪个组件中定义，只能在哪个组件中使用</p>
<p>filters: {</p>
<p>​      ‘自定义过滤器名称 - 驼峰式命名’ (需要过滤的值 - 必填且默认, 使用过滤器时传递进来的参数) {</p>
<p>​       …函数执行体</p>
<p>​       return 返回处理后的值</p>
<p>​      }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用： 在插值表达式中通过 &#123;&#123; 原始数据 | 过滤器名称 &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     &lt;div&gt;原始数据： &#123;&#123; str &#125;&#125; &lt;/div&gt;</span><br><span class="line">     &lt;div&gt;全局过滤器：&#123;&#123; str | toUp &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;局部过滤器: &#123;&#123; str | reverseStr(&#x27;*&#x27;) &#125;&#125; &lt;/div&gt;</span><br><span class="line">     &lt;div&gt;局部过滤器: &#123;&#123; str | reverseStr(&#x27;~&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;叠加过滤器使用： &#123;&#123; str | reverseStr(&#x27;*&#x27;) | toUp &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;简易大写操作： &#123;&#123; str.toUpperCase() &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;简易字符串反转： &#123;&#123; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div&gt;简易混合叠加写法： &#123;&#123;str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;).toUpperCase() &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;DemoIndex05&#x27;,</span><br><span class="line">  // 反转字符串过滤器</span><br><span class="line">  filters: &#123;</span><br><span class="line">    reverseStr (value, s) &#123;</span><br><span class="line">      return value.split(&#x27;&#x27;).reverse().join(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &#x27;helloworld&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性   computed"></a>计算属性   computed</h3><p>特点：当这个计算属性所关联的变量发生变化时，会自动的重新进行计算</p>
<p>使用场景: 当我们需要某个值，而这个值是由其他一个或多个变量通过某些逻辑处理后计算而来的时候就可以使用计算属性</p>
<p>计算属性的缓存机制：</p>
<p>​        当计算属性的对应函数执行时，会把return中的数据缓存起来，如果这个计算属性中的依赖变量没有法师改变时，当计算属性被页面多次使用并不会重新计算，而是从缓存中获取当前的计算结果。只有依赖项发生变化时，才会重新进行计算并将新的计算结果储存到缓存中</p>
<p>因为要消耗内存，所以也是计算属性的缺点</p>
<p>计算属性优势：</p>
<p>​     (1). 带缓存 </p>
<p>​     (2). 依赖项不变, 直接从缓存取</p>
<p>​     (3). 依赖项改变, 函数自动执行并重新缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">      在 export default 中有一个属性 computed</span><br><span class="line">      computed: &#123;</span><br><span class="line">        &#x27;自定义计算属性名&#x27; () &#123;</span><br><span class="line">          ...函数执行体 (其中涉及了相关的其他变量)</span><br><span class="line">          return 处理之后的值</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完整版写法：</span><br><span class="line">语法：</span><br><span class="line">      computed: &#123;</span><br><span class="line">        &#x27;自定义计算属性名称&#x27;: &#123;</span><br><span class="line">           通过依赖项，获取计算属性数据的方法</span><br><span class="line">          get () &#123;</span><br><span class="line">            ** get方法里的代码就是基本计算属性写法中的内容</span><br><span class="line">            ...函数执行体 (其中涉及了相关的其他变量)</span><br><span class="line">            return 处理之后的值</span><br><span class="line">          &#125;,</span><br><span class="line">          </span><br><span class="line">           由计算属性，主动修改依赖项的方法</span><br><span class="line">          set (value) &#123;</span><br><span class="line">             value 是计算属性set方法的默认参数  指的是当前计算属性的值</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">      &lt;span&gt;全选:&lt;/span&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll1&quot; /&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">          &lt;input type=&quot;checkbox&quot; v-model=&quot;item.checked&quot; /&gt;</span><br><span class="line">          &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;name: &quot;猪八戒&quot;,checked: false,&#125;,</span><br><span class="line">        &#123;name: &quot;孙悟空&quot;,checked: false,&#125;,</span><br><span class="line">        &#123;name: &quot;唐僧&quot;,checked: false,&#125;,</span><br><span class="line">        &#123;name: &quot;白龙马&quot;,checked: false,&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    isAll1: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        // 判断当前循环的元素是否选中状态为true</span><br><span class="line">        return this.list.every(obj =&gt; obj.checked === true);</span><br><span class="line">      &#125;,</span><br><span class="line">      set(value) &#123;</span><br><span class="line">        //所有小选框变成value</span><br><span class="line">        this.list.forEach((obj) =&gt; (obj.checked = value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="watch-监听器"><a href="#watch-监听器" class="headerlink" title="watch 监听器"></a>watch 监听器</h3><p>可以侦听data/computed属性值改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">      在 export defualt 中有一个 watch 属性</span><br><span class="line">      watch: &#123;</span><br><span class="line">        &#x27;被监听的变量/计算属性&#x27; (newValue, oldValue) &#123;</span><br><span class="line">          newValue: 数据更新后的值</span><br><span class="line">          oldValue: 数据更新前的值</span><br><span class="line">          以上两个值，特指的栈内存中的值</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>监听器的完整写法 - 深度监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">       &#x27;被监听的变量/计算属性&#x27;: &#123;</span><br><span class="line">         就是基本写法中的处理函数执行体</span><br><span class="line">         handler (newValue, oldValue) &#123;</span><br><span class="line">           newValue: 数据更新后的值</span><br><span class="line">           oldValue: 数据更新前的值</span><br><span class="line">           以上两个值，特指的栈内存中的值</span><br><span class="line">         &#125;,</span><br><span class="line">         deep: true, // 深度监听复杂数据类型的变化</span><br><span class="line">         immediate: true // 在组件渲染到页面上时，立即执行一次handler中的方法</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;str&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;obj.name&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;DemoInfo&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            str: &quot;123&quot;,</span><br><span class="line">            obj:&#123;</span><br><span class="line">                name:&quot;kk&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">    // 基本数据类型 </span><br><span class="line">        &#x27;str&#x27; (newValue,oldValue)&#123;</span><br><span class="line">            console.log(&#x27;newValue:&#x27;,newValue)</span><br><span class="line">            console.log(&#x27;newValue:&#x27;,oldValue)</span><br><span class="line">            console.log(&#x27;当前变量&#x27;,this.str)</span><br><span class="line">        &#125;,</span><br><span class="line">        // 监听的是整个对象  ×</span><br><span class="line">        &#x27;obj&#x27; : &#123;</span><br><span class="line">            handler (newValue,oldValue)&#123;</span><br><span class="line">                //结果完全一致</span><br><span class="line">            console.log(&#x27;newValue:&#x27;,newValue.name) // kk3</span><br><span class="line">            console.log(&#x27;oldValue:&#x27;,oldValue.name) // kk3</span><br><span class="line">            console.log(&#x27;当前变量&#x27;,this.obj)        //  kk3</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: true</span><br><span class="line">        &#125;,</span><br><span class="line">        //监听对象里面的具体数据  √</span><br><span class="line">        &#x27;obj.name&#x27; : &#123;</span><br><span class="line">            handler (newValue,oldValue)&#123;</span><br><span class="line">            console.log(&#x27;newValue:&#x27;,newValue) //kk3</span><br><span class="line">            console.log(&#x27;oldValue:&#x27;,oldValue) //kk</span><br><span class="line">            console.log(&#x27;当前变量&#x27;,this.obj)   //kk3</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: true</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>路由配置，声明式导航传参、编程式导航传参，路由守卫，路由重定向</title>
    <url>/2022/12/02/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%BC%A0%E5%8F%82%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%BC%A0%E5%8F%82%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%8C%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><p>步骤：</p>
<ol>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 1. 下载vue-router</span><br><span class="line">npm i vue-router@3.5.1</span><br></pre></td></tr></table></figure></li>
<li><p>在main.js 中导入路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2. 引入</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>使用路由插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在vue中，使用使用vue的插件，都需要调用Vue.use()</span><br><span class="line">// 3. 注册全局组件</span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></li>
<li><p>创建路由规则数组 -  规则指的是：建立路由与页面组件的一一对应关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 4.1 引入页面组件</span><br><span class="line">import Find from &#x27;./views/Find.vue&#x27; // @是src的绝对地址</span><br><span class="line">import My from &#x27;./views/My.vue&#x27;</span><br><span class="line">import Part from &#x27;./views/Part.vue&#x27;</span><br><span class="line">// 4.2 规则数组</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/find&quot;, // 路由</span><br><span class="line">    component: Find， // 组件名称</span><br><span class="line">      children: [ // 二级路由数组</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;recommend&#x27;,</span><br><span class="line">        component: Recommend</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;ranking&#x27;,</span><br><span class="line">        component: Ranking</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;songList&#x27;,</span><br><span class="line">        component: SongList</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/my&quot;,</span><br><span class="line">    component: My</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/part&quot;,</span><br><span class="line">    component: Part</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>创建路由对象 -  传入规则</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 5. 生成路由对象（传入配置对象）</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,// routes是固定key(传入规则数组)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>5.5   创建完路由实例后，可以设置路由守卫</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路由前置守卫 beforeEach</span><br><span class="line">  语法: </span><br><span class="line">  router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    to: 要跳转到那个路由地址 - 目标</span><br><span class="line">    from: 从哪里跳转过去 - 来源</span><br><span class="line">    next: 接下来该干嘛（1. 阻止跳转，    2. 正常跳转    3. 改变跳转） - 行为</span><br><span class="line">      =&gt;                next(false)    next(true)     next(&#x27;/改变跳转的路由地址&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(to, from)</span><br><span class="line">  // 1. 如果是从 /my 跳转到 /part 时，阻止跳转</span><br><span class="line">  if (from.path === &#x27;/my&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(false)</span><br><span class="line">    // 2. 如果从 /find 跳转到 /part时，转为跳转到 /my</span><br><span class="line">  &#125; else if (from.path === &#x27;/find&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(&#x27;/my&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>关联到vue实例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>设置App.vue引入挂载路由组件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;footer_wrap&quot;&gt;</span><br><span class="line">      &lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;#/part&quot;&gt;朋友&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;</span><br><span class="line">      &lt;!-- 7. 设置挂载点-当url的hash值路径切换, 显示规则里对应的组件到这 --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="声明式导航-通过标签进行路由跳转"><a href="#声明式导航-通过标签进行路由跳转" class="headerlink" title="声明式导航 - 通过标签进行路由跳转"></a><strong>声明式导航 - 通过标签进行路由跳转</strong></h3><ol>
<li> vue-router提供了一个全局组件 router-link</li>
<li> router-link实质上最终会渲染成a链接 to属性等价于提供 href属性**(to无需#)**</li>
<li> router-link提供了声明式导航高亮的功能(自带类名)</li>
</ol>
<p>总结 router-link 标签与 a标签 的区别</p>
<ol>
<li><p>虽然在vue模板中写作 router-link, 但是在真实dom挂载后本质上是 a标签</p>
</li>
<li><p>to 属性 代替了 href属性 进行页面跳转</p>
</li>
<li><p>to属性后面接的路由地址不必带 # 号</p>
</li>
<li><p>router-link 自带了2个class类名 router-link-exact-active / router-link-active</p>
<p>​      =&gt; 这两个类可以作为路由导航的高亮类名来使用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#/part&quot;&gt;朋友&lt;/a&gt;</span><br><span class="line">上下效果一样</span><br><span class="line">&lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part?userName=小坤&quot;&gt;朋友A&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part/东东&quot;&gt;朋友B&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h5 id="声明式导航传参的两种方式"><a href="#声明式导航传参的两种方式" class="headerlink" title="声明式导航传参的两种方式"></a>声明式导航传参的两种方式</h5><p>1.to=”/路由地址?参数名1=参数值1&amp;参数名2=参数值2”</p>
<p>​     =&gt; 接收: 在对应组件中， 以 $route.query.参数名 的形式进行接收对应参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;router-link to=&quot;/part?userName=小坤&quot;&gt;朋友A&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part/东东&quot;&gt;朋友B&lt;/router-link&gt;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;query接收参数： 双&#123; $route.query.userName 双&#123; &lt;div&gt;</span><br><span class="line">&lt;div&gt;params接收参数： 双&#123; $route.params.userName 双 &lt;div&gt;</span><br></pre></td></tr></table></figure>

<p>2.to=”/路由地址/参数值”</p>
<p>​      在路由规则数组的对应路由地址中，需要设置 path: ‘/路由地址/:参数名’</p>
<p>​     =&gt; 接收：在对应组件中，以 $route.params.参数名 的形式进行接收对应参数</p>
<p> 注意事项： 如果使用 /路由地址/参数值 的传参方式，那么原本正常的不传参的路由将无法被访问到</p>
<p>​     解决办法:  可以再创建一个没有传参要求的路由规则</p>
<p>第一种方法的优势：</p>
<ol>
<li><p>传参代码都在一个文件中，方便阅读</p>
</li>
<li><p>方法二需要重新创建一个带有传参规则的路由规则对象，麻烦</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;router-link to=&quot;/part?userName=小坤&quot;&gt;朋友A&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/part/东东&quot;&gt;朋友B&lt;/router-link&gt;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;query接收参数： 双&#123; $route.query.userName 双&#123;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;params接收参数： 双&#123; $route.params.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由重定向和模式修改"><a href="#路由重定向和模式修改" class="headerlink" title="路由重定向和模式修改"></a>路由重定向和模式修改</h3><p>场景：首次进入页面时，没有任何路由的hash值，页面元素会显示空白，如何解决？</p>
<p><strong>实际作用：</strong></p>
<ol>
<li>当某个路由在使用过程中废弃掉之后，将原来路由地址重定向到其他地址</li>
<li>当满足某个条件时（如：登录信息过期），可以重定向到某个指定位置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/&quot;, // 默认hash值路径</span><br><span class="line">    redirect: &quot;/find&quot; // 重定向到/find</span><br><span class="line">    // 浏览器url中#后的路径被改变成/find-重新匹配数组规则</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="路由-404页面"><a href="#路由-404页面" class="headerlink" title="路由 - 404页面"></a>路由 - 404页面</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import NotFound from &#x27;@/views/NotFound&#x27;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  // ...省略了其他配置</span><br><span class="line">  // 404在最后(规则是从前往后逐个比较path)</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;*&quot;,</span><br><span class="line">    component: NotFound</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="模式修改"><a href="#模式修改" class="headerlink" title="模式修改"></a>模式修改</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">1. hash 模式（默认）: 网址中带有 # 号</span><br><span class="line">2. history模式： 网址中不带 # 号</span><br><span class="line">history模式的路由形式 与 接口请求形式是一致的，后端在不做任何配置的情况下是无法分别究竟是路由跳转还是接口请求，所以如果以后需要在项目中做history模式的路由跳转时，需要后端同事的支持</span><br><span class="line">  routes,</span><br><span class="line">  mode: &quot;history&quot; // 打包上线后需要后台支持, 模式是hash</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式传参才有name</p>
<p><strong>代码规范：</strong>一般情况下，path除去<code>/</code>以外的部分和name需要保持一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">    path: &quot;路由路径&quot;</span><br><span class="line">    name: &quot;路由名&quot;,</span><br><span class="line">    query: &#123;</span><br><span class="line">    	&quot;参数名&quot;: 值</span><br><span class="line">    &#125;</span><br><span class="line">    params: &#123;</span><br><span class="line">		&quot;参数名&quot;: 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 方式1:</span><br><span class="line">// params =&gt; $route.params.参数名</span><br><span class="line"></span><br><span class="line">// 方式2:</span><br><span class="line">// query =&gt; $route.query.参数名</span><br></pre></td></tr></table></figure>

<p> 注意事项： 编程式导航会遇到一个小问题，当处在A路由上时，想用编程式导航跳转到A路由，会报出错误阻止你重复的跳转<br>        传参特点：</p>
<pre><code>         1. path跳转用query发送数据， name跳转用params发送数据
         2. query传参会拼接到url上，而params传参不会拼接到url上
         3. 通过编程式导航的params传参，如果刷新页面，传递的数据会消失
         4. name也可以使用query传参，但为了保证代码的统一性，尽量不要使用这种传参方式
</code></pre>
<h5 id="编程式导航的传参的两种方法"><a href="#编程式导航的传参的两种方法" class="headerlink" title="编程式导航的传参的两种方法"></a>编程式导航的传参的两种方法</h5><ol>
<li>this.$router.push({</li>
</ol>
<p>​     path: ‘/路由地址’, // 需要跳转到的路由地址</p>
<p>​     query: {} // path跳转用query来发送数据</p>
<p>​    })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;span @click=&quot;goPath(&#x27;/part&#x27;, &#x27;part&#x27;)&quot;&gt;朋友A&lt;/span&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> methods: &#123;</span><br><span class="line">    // 通过path属性进行跳转</span><br><span class="line">    goPath (myPath, myName) &#123;</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">        path: myPath,</span><br><span class="line">        query: &#123;</span><br><span class="line">          userName: &#x27;东东&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;query接收参数： 双&#123; $route.query.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>this.$router.push({</li>
</ol>
<p>​     name: ‘路由名称’, // 在路由规则数组中配置的路由名称</p>
<p>​     params: {} // name跳转用params发送数据</p>
<p>​    })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送参数的组件</span><br><span class="line">&lt;span @click=&quot;goName(&#x27;/part&#x27;, &#x27;part&#x27;)&quot;&gt;朋友B&lt;/span&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> methods: &#123;</span><br><span class="line">    // 通过name属性进行跳转</span><br><span class="line">    goName (myPath, myName) &#123;</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">        name: myName,</span><br><span class="line">        params: &#123;</span><br><span class="line">          userName: &#x27;欢欢&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">接收参数的组件</span><br><span class="line">&lt;div&gt;params接收参数： 双&#123; $route.params.userName 双&#123;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p> 路由与路由之间也可能存在嵌套关系</p>
<p>注意事项：</p>
<p>​     1. 要明确一级路由、二级路由等等他们的挂载点到底在那个组件上，在对应组件中设置router-view</p>
<pre><code>    2. 非一级路由的规则对象中path属性不可以添加 &#39;/&#39;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法： 如果两个页面组件存在路由的嵌套关系，那么可以在路由规则数组中以children属性定义嵌套</span><br><span class="line">          &#123;</span><br><span class="line">            path: &#x27;/一级路由&#x27;,</span><br><span class="line">            component: &#x27;外层组件&#x27;,</span><br><span class="line">            children: [</span><br><span class="line">              &#123;</span><br><span class="line">                path: &#x27;二级路由&#x27;,</span><br><span class="line">                component: &#x27;内层组件&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">使用是要把一级路由二级路由....后续的所有联系拼接好后作出跳转</span><br><span class="line">to=&quot;/一级路由/二级路由/...&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路由配置4.2中</span><br><span class="line">const routes = [</span><br><span class="line">      &#123;</span><br><span class="line">    path: &#x27;/find&#x27;, // 路由</span><br><span class="line">    name: &#x27;find&#x27;,</span><br><span class="line">    component: Find, // 组件</span><br><span class="line">    children: [ // 二级路由数组</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;recommend&#x27;,</span><br><span class="line">        component: Recommend</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">在一级路由中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link to=&quot;/find/recommend&quot;&gt;推荐&lt;/router-link&gt;</span><br><span class="line">    &lt;div style=&quot;border: 1px solid red;&quot;&gt;</span><br><span class="line">      &lt;!-- 二级路由的挂载点 --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="声明导航-类名区别"><a href="#声明导航-类名区别" class="headerlink" title="声明导航 - 类名区别"></a>声明导航 - 类名区别</h3><p>声明式导航两个类名的意义</p>
<p>​     router-link-exact-active：(精确匹配)  router-link 中 to属性里的路由地址完全匹配浏览器url上的路由地址时出现</p>
<p>​     router-link-active: (模糊匹配) router-link 中 to属性里的路由地址一部分 包含在 浏览器url上的路由地址时 出现</p>
<h3 id="全局前置守卫（路由守卫）-beforeEach"><a href="#全局前置守卫（路由守卫）-beforeEach" class="headerlink" title="全局前置守卫（路由守卫） beforeEach"></a>全局前置守卫（路由守卫） beforeEach</h3><p>目的: 路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法: </span><br><span class="line">  router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    to: 要跳转到那个路由地址 - 目标</span><br><span class="line">    from: 从哪里跳转过去 - 来源</span><br><span class="line">    next: 接下来该干嘛（1. 阻止跳转，    2. 正常跳转    3. 改变跳转） - 行为</span><br><span class="line">      =&gt;                next(false)    next(true)     next(&#x27;/改变跳转的路由地址&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(to, from)</span><br><span class="line">  // 1. 如果是从 /my 跳转到 /part 时，阻止跳转</span><br><span class="line">  if (from.path === &#x27;/my&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(false)</span><br><span class="line">    // 2. 如果从 /find 跳转到 /part时，转为跳转到 /my</span><br><span class="line">  &#125; else if (from.path === &#x27;/find&#x27; &amp;&amp; to.path === &#x27;/part&#x27;) &#123;</span><br><span class="line">    next(&#x27;/my&#x27;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// next(true) === next()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>生产级--路由封装，接口请求</title>
    <url>/2022/12/04/%E7%94%9F%E4%BA%A7%E7%BA%A7-%E8%B7%AF%E7%94%B1%E5%B0%81%E8%A3%85%EF%BC%8C%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="引入和导出的两种方法"><a href="#引入和导出的两种方法" class="headerlink" title="引入和导出的两种方法"></a>引入和导出的两种方法</h3><ol>
<li><p>导出：export</p>
<p>导入：import { 对应导出的那个变量名 } from ‘路径’</p>
<p>可以一次导出多个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出文件      </span><br><span class="line">export const request1 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://www.escook.cn&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const request2 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://www.xxxx.cn&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">导入文件</span><br><span class="line">import &#123; request1,  request2&#125; from &#x27;导出文件 &#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>导出：export default</p>
<p> 默认导出一个文件中只能导出一个内容</p>
<p>  导入：import 自定义变量 from ‘路径’</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出文件      </span><br><span class="line">export const request1 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://www.escook.cn&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const request2 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://www.xxxx.cn&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">导入文件</span><br><span class="line">export default request1 或者 request2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="路由封装"><a href="#路由封装" class="headerlink" title="路由封装"></a>路由封装</h3><p>为什么要封装？</p>
<p>因为在创建规则数组时，要求引入多个vue，写多个配置对象</p>
<p>在src中，创建一个router文件夹，里面有一个index.js文件，路由的配置前5步放入其中，然后导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 下载vue-router依赖， npm i vue-router@3.5.1</span><br><span class="line">// 2. 引入路由</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">// 3. 使用</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">// 4. 创建规则数组</span><br><span class="line">import Home from &#x27;../views/home.vue&#x27;</span><br><span class="line">import Pay from &#x27;../views/pay.vue&#x27;</span><br><span class="line">import UserInfo from &#x27;../views/userInfo.vue&#x27;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/pay&#x27;,</span><br><span class="line">    component: Pay</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/userInfo&#x27;,</span><br><span class="line">    component: UserInfo</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 5. 创建路由实例化对象</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br><span class="line"></span><br><span class="line">main.js中</span><br><span class="line">new Vue(&#123; // 实例化vue对象</span><br><span class="line">  // 6. 关联vue对象</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line">挂载文件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="接口请求"><a href="#接口请求" class="headerlink" title="接口请求"></a>接口请求</h3><h4 id="1-全局配置接口请求模块"><a href="#1-全局配置接口请求模块" class="headerlink" title="1. 全局配置接口请求模块"></a>1. 全局配置接口请求模块</h4><p>在src中创建一个utils工具文件夹，在里面创建一个request.js文件用来存储<strong>全局配置接口请求模块</strong></p>
<p>目的：当以后url改变时，能够在同一的地方进行配置使用，在此文件修改根域名，不用满文件去找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">// 2. 创建并导出请求基本地址配置</span><br><span class="line">// 目的：当以后url改变时，能够在同一的地方进行配置使用</span><br><span class="line">export const request1 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://www.escook.cn&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const request2 = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;https://www.xxxx.cn&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-按照需求对接口进行分类"><a href="#2-按照需求对接口进行分类" class="headerlink" title="2. 按照需求对接口进行分类"></a>2. 按照需求对接口进行分类</h4><p>在src中创建一个api接口文件夹，在里面分类创建不同的功能的方法模块，方便使用接口（需要按照业务需求进行接口的分类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api文件夹goods.js中</span><br><span class="line">// 商品相关接口模块 - api功能方法模块</span><br><span class="line">// /api/goods</span><br><span class="line">// 引入根接口，拼接接口地址即可</span><br><span class="line">import &#123; request1 &#125; from &#x27;../utils/request.js&#x27;</span><br><span class="line"></span><br><span class="line">// 获取商品列表</span><br><span class="line">export const GetGoodsList = () =&gt; request1(&#123;</span><br><span class="line">  method: &#x27;GET&#x27;,</span><br><span class="line">  url: &#x27;/api/goods&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api文件夹user.js中</span><br><span class="line">// 用户相关接口模块 - api功能方法模块</span><br><span class="line">// /login</span><br><span class="line">import &#123; request2 &#125; from &#x27;../utils/request.js&#x27;</span><br><span class="line"></span><br><span class="line">// 用户登录</span><br><span class="line">export const login = data =&gt; request2(&#123;</span><br><span class="line">  method: &#x27;POST&#x27;,</span><br><span class="line">  url: &#x27;/login&#x27;,</span><br><span class="line">  data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 获取验证码</span><br><span class="line">export const getSms = params =&gt; request2(&#123;</span><br><span class="line">  method: &#x27;GET&#x27;,</span><br><span class="line">  url: &#x27;/getSms&#x27;,</span><br><span class="line">  params</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-api统一汇总导出"><a href="#3-api统一汇总导出" class="headerlink" title="3. api统一汇总导出"></a>3. api统一汇总导出</h4><p>src中创建一个api接口文件夹，在里面创建index.js文件，用于做api中所有分类接口的统一导出文件（因为这样做，需要接口的组件，只需要导入这一个js文件，就可以获得所有的接口，按需要自取）</p>
<p>作用：引入各个功能模块中的接口方法，再次统一导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api文件夹index.js中</span><br><span class="line"></span><br><span class="line">import &#123; GetGoodsList &#125; from &#x27;./goods.js&#x27;</span><br><span class="line">import &#123; login, getSms &#125; from &#x27;./user.js&#x27;</span><br><span class="line"></span><br><span class="line">export const GetGoodsListAPI = GetGoodsList</span><br><span class="line">export const loginAPI = login</span><br><span class="line">export const getSmsAPI = getSms</span><br></pre></td></tr></table></figure>

<h4 id="4-使用接口"><a href="#4-使用接口" class="headerlink" title="4. 使用接口"></a>4. 使用接口</h4><p>在需要接口的组件中，引入所有的scr/api/index.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入 scr/api/index.js文件</span><br><span class="line">import &#123; GetGoodsListAPI, loginAPI, getSmsAPI &#125; from &#x27;./api/index.js&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">	created () &#123;</span><br><span class="line">		GetGoodsListAPI().then(res =&gt; &#123;</span><br><span class="line">      	 console.log(&#x27;请求成功时&#x27;, res)</span><br><span class="line">       	&#125;).catch(err =&gt; &#123;</span><br><span class="line">      	 console.log(&#x27;请求失败&#x27;, err)</span><br><span class="line">     	&#125;),</span><br><span class="line">     	</span><br><span class="line">     	loginAPI(&#123;</span><br><span class="line">     	//传参</span><br><span class="line">     		userName: this.form.userName,</span><br><span class="line">            password: this.form.password</span><br><span class="line">     	&#125;).then(res =&gt; &#123;</span><br><span class="line">      	 console.log(&#x27;请求成功时&#x27;, res)</span><br><span class="line">      	 &#125;).catch(err =&gt; &#123;</span><br><span class="line">      	 console.log(&#x27;请求失败&#x27;, err)</span><br><span class="line">     	&#125;),</span><br><span class="line">	&#125;,</span><br><span class="line">	data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      form: &#123;</span><br><span class="line">        userName: &#x27;&#x27;,</span><br><span class="line">        password: &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法，容易照成<strong>请求地狱</strong>（例如：loginAPI接口的数据必须在GetGoodsListAPI返回后才能请求，多几个就看神了）</p>
<p>解决方法：async await try catch 四兄弟 - 当某个方法需要调用接口时，直接写出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入 scr/api/index.js文件</span><br><span class="line">import &#123; GetGoodsListAPI, loginAPI, getSmsAPI &#125; from &#x27;./api/index.js&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">	created () &#123;</span><br><span class="line">		// 加载数据</span><br><span class="line">		this.loadInfo()</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">    async loadInfo () &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let res = await GetGoodsListAPI()</span><br><span class="line">        let res2 = await loginAPI()</span><br><span class="line">        let res3 = await getSmsAPI()</span><br><span class="line"></span><br><span class="line">        console.log(res, res2, res3)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        console.log(&#x27;请求失败&#x27;, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>实现本地存储需求（数据持久化）</title>
    <url>/2022/12/08/%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E9%9C%80%E6%B1%82%EF%BC%88%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<h1 id="实现本地存储需求（数据持久化）"><a href="#实现本地存储需求（数据持久化）" class="headerlink" title="实现本地存储需求（数据持久化）"></a>实现本地存储需求（数据持久化）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 本地存储相关方法模块 (数据持久化)</span><br><span class="line"></span><br><span class="line">// 存储数据（增，改）</span><br><span class="line">export const setItem = (key, value) =&gt; &#123;</span><br><span class="line">  // 将引用数据类型（数组，对象）转化为json字符串进行存储</span><br><span class="line">  if (typeof value === &#x27;object&#x27;) &#123;</span><br><span class="line">    value = JSON.stringify(value)</span><br><span class="line">  &#125;</span><br><span class="line">  localStorage.setItem(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取数据（查）</span><br><span class="line">export const getItem = key =&gt; &#123;</span><br><span class="line">  const data = localStorage.getItem(key)</span><br><span class="line">  try &#123;</span><br><span class="line">    return JSON.parse(data)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    return data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除数据（删）</span><br><span class="line">export const removeItem = key =&gt; &#123;</span><br><span class="line">  localStorage.removeItem(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
